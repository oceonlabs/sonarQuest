{"version":3,"file":"compilers.js","sources":["../../src/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport { isIdentifier, isVariableDeclarator } from '@babel/types'\nimport { codeFrameColumns } from '@babel/code-frame'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nexport interface DirectiveFn {\n  nodePath: SupportedFunctionPath\n  functionName: string\n  functionId: string\n  extractedFilename: string\n  filename: string\n  chunkName: string\n}\n\nexport type SupportedFunctionPath =\n  | babel.NodePath<babel.types.FunctionDeclaration>\n  | babel.NodePath<babel.types.FunctionExpression>\n  | babel.NodePath<babel.types.ArrowFunctionExpression>\n\nexport type ReplacerFn = (opts: {\n  fn: string\n  extractedFilename: string\n  filename: string\n  functionId: string\n  isSourceFn: boolean\n}) => string\n\n// const debug = process.env.TSR_VITE_DEBUG === 'true'\n\nexport type CompileDirectivesOpts = ParseAstOptions & {\n  directive: string\n  directiveLabel: string\n  getRuntimeCode?: (opts: {\n    directiveFnsById: Record<string, DirectiveFn>\n  }) => string\n  replacer: ReplacerFn\n  // devSplitImporter: string\n  filename: string\n  root: string\n}\n\nfunction buildDirectiveSplitParam(opts: CompileDirectivesOpts) {\n  return `tsr-directive-${opts.directive.replace(/[^a-zA-Z0-9]/g, '-')}`\n}\n\nexport function compileDirectives(opts: CompileDirectivesOpts): {\n  compiledResult: GeneratorResult\n  directiveFnsById: Record<string, DirectiveFn>\n  isDirectiveSplitParam: boolean\n} {\n  const directiveSplitParam = buildDirectiveSplitParam(opts)\n  const isDirectiveSplitParam = opts.filename.includes(directiveSplitParam)\n\n  const ast = parseAst(opts)\n  const refIdents = findReferencedIdentifiers(ast)\n  const directiveFnsById = findDirectives(ast, {\n    ...opts,\n    directiveSplitParam,\n  })\n\n  // Add runtime code if there are directives\n  if (Object.keys(directiveFnsById).length > 0) {\n    if (opts.getRuntimeCode) {\n      const runtimeImport = babel.template.statement(\n        opts.getRuntimeCode({ directiveFnsById }),\n      )()\n      ast.program.body.unshift(runtimeImport)\n    }\n  }\n\n  // If we are in the source file, we need to remove all exports\n  // then make sure that all of our functions are exported under their\n  // directive name\n  if (isDirectiveSplitParam) {\n    safeRemoveExports(ast)\n\n    // Export a single object with all of the functions\n    // e.g. export { directiveFn1, directiveFn2 }\n    ast.program.body.push(\n      babel.types.exportNamedDeclaration(\n        undefined,\n        Object.values(directiveFnsById).map((fn) =>\n          babel.types.exportSpecifier(\n            babel.types.identifier(fn.functionName),\n            babel.types.identifier(fn.functionName),\n          ),\n        ),\n      ),\n    )\n  }\n\n  deadCodeElimination(ast, refIdents)\n\n  const compiledResult = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n\n  return {\n    compiledResult,\n    directiveFnsById,\n    isDirectiveSplitParam,\n  }\n}\n\nfunction findNearestVariableName(\n  path: babel.NodePath,\n  directiveLabel: string,\n): string {\n  let currentPath: babel.NodePath | null = path\n  const nameParts: Array<string> = []\n\n  while (currentPath) {\n    const name = (() => {\n      // Check for named function expression\n      if (\n        babel.types.isFunctionExpression(currentPath.node) &&\n        currentPath.node.id\n      ) {\n        return currentPath.node.id.name\n      }\n\n      // Handle method chains\n      if (babel.types.isCallExpression(currentPath.node)) {\n        const current = currentPath.node.callee\n        const chainParts: Array<string> = []\n\n        // Get the nearest method name (if it's a method call)\n        if (babel.types.isMemberExpression(current)) {\n          if (babel.types.isIdentifier(current.property)) {\n            chainParts.unshift(current.property.name)\n          }\n\n          // Get the base callee\n          let base = current.object\n          while (!babel.types.isIdentifier(base)) {\n            if (babel.types.isCallExpression(base)) {\n              base = base.callee as babel.types.Expression\n            } else if (babel.types.isMemberExpression(base)) {\n              base = base.object\n            } else {\n              break\n            }\n          }\n          if (babel.types.isIdentifier(base)) {\n            chainParts.unshift(base.name)\n          }\n        } else if (babel.types.isIdentifier(current)) {\n          chainParts.unshift(current.name)\n        }\n\n        if (chainParts.length > 0) {\n          return chainParts.join('_')\n        }\n      }\n\n      // Rest of the existing checks...\n      if (babel.types.isFunctionDeclaration(currentPath.node)) {\n        return currentPath.node.id?.name\n      }\n\n      if (babel.types.isIdentifier(currentPath.node)) {\n        return currentPath.node.name\n      }\n\n      if (\n        isVariableDeclarator(currentPath.node) &&\n        isIdentifier(currentPath.node.id)\n      ) {\n        return currentPath.node.id.name\n      }\n\n      if (\n        babel.types.isClassMethod(currentPath.node) ||\n        babel.types.isObjectMethod(currentPath.node)\n      ) {\n        throw new Error(\n          `${directiveLabel} in ClassMethod or ObjectMethod not supported`,\n        )\n      }\n\n      return ''\n    })()\n\n    if (name) {\n      nameParts.unshift(name)\n    }\n\n    currentPath = currentPath.parentPath\n  }\n\n  return nameParts.length > 0 ? nameParts.join('_') : 'anonymous'\n}\n\nfunction makeFileLocationUrlSafe(location: string): string {\n  return location\n    .replace(/[^a-zA-Z0-9-_]/g, '_') // Replace unsafe chars with underscore\n    .replace(/_{2,}/g, '_') // Collapse multiple underscores\n    .replace(/^_|_$/g, '') // Trim leading/trailing underscores\n    .replace(/_--/g, '--') // Clean up the joiner\n}\n\nfunction makeIdentifierSafe(identifier: string): string {\n  return identifier\n    .replace(/[^a-zA-Z0-9_$]/g, '_') // Replace unsafe chars with underscore\n    .replace(/^[0-9]/, '_$&') // Prefix leading number with underscore\n    .replace(/^\\$/, '_$') // Prefix leading $ with underscore\n    .replace(/_{2,}/g, '_') // Collapse multiple underscores\n    .replace(/^_|_$/g, '') // Trim leading/trailing underscores\n}\n\nexport function findDirectives(\n  ast: babel.types.File,\n  opts: ParseAstOptions & {\n    directive: string\n    directiveLabel: string\n    replacer?: ReplacerFn\n    directiveSplitParam: string\n    filename: string\n    root: string\n  },\n): Record<string, DirectiveFn> {\n  const directiveFnsById: Record<string, DirectiveFn> = {}\n  const functionNameSet: Set<string> = new Set()\n\n  let programPath: babel.NodePath<babel.types.Program>\n\n  babel.traverse(ast, {\n    Program(path) {\n      programPath = path\n    },\n  })\n\n  // Does the file have the directive in the program body?\n  const hasFileDirective = ast.program.directives.some(\n    (directive) => directive.value.value === opts.directive,\n  )\n\n  // If the entire file has a directive, we need to compile all of the functions that are\n  // exported by the file.\n  if (hasFileDirective) {\n    // Find all of the exported functions\n    // They must be either function declarations or const function/anonymous function declarations\n    babel.traverse(ast, {\n      ExportDefaultDeclaration(path) {\n        if (babel.types.isFunctionDeclaration(path.node.declaration)) {\n          compileDirective(path.get('declaration') as SupportedFunctionPath)\n        }\n      },\n      ExportNamedDeclaration(path) {\n        if (babel.types.isFunctionDeclaration(path.node.declaration)) {\n          compileDirective(path.get('declaration') as SupportedFunctionPath)\n        }\n      },\n      ExportDeclaration(path) {\n        if (\n          babel.types.isExportNamedDeclaration(path.node) &&\n          babel.types.isVariableDeclaration(path.node.declaration) &&\n          (babel.types.isFunctionExpression(\n            path.node.declaration.declarations[0]?.init,\n          ) ||\n            babel.types.isArrowFunctionExpression(\n              path.node.declaration.declarations[0]?.init,\n            ))\n        ) {\n          compileDirective(\n            path.get(\n              'declaration.declarations.0.init',\n            ) as SupportedFunctionPath,\n          )\n        }\n      },\n    })\n  } else {\n    // Find all directives\n    babel.traverse(ast, {\n      DirectiveLiteral(nodePath) {\n        if (nodePath.node.value === opts.directive) {\n          const directiveFn = nodePath.findParent((p) => p.isFunction())\n\n          if (!directiveFn) return\n\n          // Handle class and object methods which are not supported\n          const isClassMethod = directiveFn.isClassMethod()\n          const isObjectMethod = directiveFn.isObjectMethod()\n\n          if (isClassMethod || isObjectMethod) {\n            throw codeFrameError(\n              opts.code,\n              directiveFn.node.loc,\n              `\"${opts.directive}\" in ${isClassMethod ? 'class' : isObjectMethod ? 'object method' : ''} not supported`,\n            )\n          }\n\n          // If the function is inside another block that isn't the program,\n          // Error out. This is not supported.\n          const nearestBlock = directiveFn.findParent(\n            (p) => (p.isBlockStatement() || p.isScopable()) && !p.isProgram(),\n          )\n\n          if (nearestBlock) {\n            throw codeFrameError(\n              opts.code,\n              nearestBlock.node.loc,\n              `${opts.directiveLabel}s cannot be nested in other blocks or functions`,\n            )\n          }\n\n          if (\n            !directiveFn.isFunctionDeclaration() &&\n            !directiveFn.isFunctionExpression() &&\n            !(\n              directiveFn.isArrowFunctionExpression() &&\n              babel.types.isBlockStatement(directiveFn.node.body)\n            )\n          ) {\n            throw codeFrameError(\n              opts.code,\n              directiveFn.node.loc,\n              `${opts.directiveLabel}s must be function declarations or function expressions`,\n            )\n          }\n\n          compileDirective(directiveFn)\n        }\n      },\n    })\n  }\n\n  return directiveFnsById\n\n  function compileDirective(directiveFn: SupportedFunctionPath) {\n    // Move the function to program level while preserving its position\n    // in the program body\n    const programBody = programPath.node.body\n\n    // Remove the directive directive from the function body\n    if (\n      babel.types.isFunction(directiveFn.node) &&\n      babel.types.isBlockStatement(directiveFn.node.body)\n    ) {\n      directiveFn.node.body.directives =\n        directiveFn.node.body.directives.filter(\n          (directive) => directive.value.value !== opts.directive,\n        )\n    }\n\n    // if the directive function is a top-level function, we need to create a const declaration\n    // using the same name as the function and replace the function with the variable declaration\n    // that points to the function\n    if (directiveFn.parentPath.isProgram()) {\n      if (!babel.types.isFunctionDeclaration(directiveFn.node)) {\n        throw new Error('Top level functions must be function declarations')\n      }\n\n      const index = programBody.indexOf(directiveFn.node)\n\n      // First get the name of the function\n      const originalFunctionName = directiveFn.node.id!.name\n\n      // Now turn the function into an anonymous function\n      directiveFn.node.id = null\n\n      const variableDeclaration = babel.types.variableDeclaration('const', [\n        babel.types.variableDeclarator(\n          babel.types.identifier(originalFunctionName),\n          babel.types.toExpression(directiveFn.node as any),\n        ),\n      ])\n\n      directiveFn.replaceWith(variableDeclaration)\n\n      directiveFn = programPath.get(\n        `body.${index}.declarations.0.init`,\n      ) as SupportedFunctionPath\n    }\n\n    // Find the nearest variable name\n    let functionName = findNearestVariableName(directiveFn, opts.directiveLabel)\n\n    const incrementFunctionNameVersion = (functionName: string) => {\n      const [realReferenceName, count] = functionName.split(/_(\\d+)$/)\n      const resolvedCount = Number(count || '0')\n      const suffix = `_${resolvedCount + 1}`\n      return makeIdentifierSafe(realReferenceName!) + suffix\n    }\n\n    while (functionNameSet.has(functionName)) {\n      functionName = incrementFunctionNameVersion(functionName)\n    }\n\n    functionNameSet.add(functionName)\n\n    while (programPath.scope.hasBinding(functionName)) {\n      functionName = incrementFunctionNameVersion(functionName)\n      programPath.scope.crawl()\n    }\n\n    functionNameSet.add(functionName)\n\n    const topParent =\n      directiveFn.findParent((p) => !!p.parentPath?.isProgram()) || directiveFn\n\n    const topParentIndex = programBody.indexOf(topParent.node as any)\n\n    // If the function has a parent that isn't the program,\n    // we need to replace it with an identifier and\n    // hoist the function to the top level as a const declaration\n    if (directiveFn.parentPath.isProgram()) {\n      throw new Error(\n        'Top level functions should have already been compiled to variable declarations by this point',\n      )\n    }\n    // Then place the function at the top level\n    programBody.splice(\n      topParentIndex,\n      0,\n      babel.types.variableDeclaration('const', [\n        babel.types.variableDeclarator(\n          babel.types.identifier(functionName),\n          babel.types.toExpression(directiveFn.node as any),\n        ),\n      ]),\n    )\n\n    // If it's an exported named function, we need to swap it with an\n    // export const originalFunctionName = functionName\n    if (\n      babel.types.isExportNamedDeclaration(directiveFn.parentPath.node) &&\n      (babel.types.isFunctionDeclaration(directiveFn.node) ||\n        babel.types.isFunctionExpression(directiveFn.node)) &&\n      babel.types.isIdentifier(directiveFn.node.id)\n    ) {\n      const originalFunctionName = directiveFn.node.id.name\n      programBody.splice(\n        topParentIndex + 1,\n        0,\n        babel.types.exportNamedDeclaration(\n          babel.types.variableDeclaration('const', [\n            babel.types.variableDeclarator(\n              babel.types.identifier(originalFunctionName),\n              babel.types.identifier(functionName),\n            ),\n          ]),\n        ),\n      )\n\n      directiveFn.remove()\n    } else {\n      directiveFn.replaceWith(babel.types.identifier(functionName))\n    }\n\n    directiveFn = programPath.get(\n      `body.${topParentIndex}.declarations.0.init`,\n    ) as SupportedFunctionPath\n\n    const [baseFilename, ..._searchParams] = opts.filename.split('?')\n    const searchParams = new URLSearchParams(_searchParams.join('&'))\n    searchParams.set(opts.directiveSplitParam, '')\n\n    const extractedFilename = `${baseFilename}?${searchParams.toString()}`\n\n    const functionId = makeFileLocationUrlSafe(\n      `${baseFilename}--${functionName}`.replace(opts.root, ''),\n    )\n\n    // If a replacer is provided, replace the function with the replacer\n    if (opts.replacer) {\n      const replacer = opts.replacer({\n        fn: '$$fn$$',\n        extractedFilename,\n        filename: opts.filename,\n        functionId,\n        isSourceFn: !!opts.directiveSplitParam,\n      })\n\n      const replacement = babel.template.expression(replacer, {\n        placeholderPattern: false,\n        placeholderWhitelist: new Set(['$$fn$$']),\n      })({\n        ...(replacer.includes('$$fn$$')\n          ? { $$fn$$: babel.types.toExpression(directiveFn.node) }\n          : {}),\n      })\n\n      directiveFn.replaceWith(replacement)\n    }\n\n    // Finally register the directive to\n    // our map of directives\n    directiveFnsById[functionId] = {\n      nodePath: directiveFn,\n      functionName,\n      functionId,\n      extractedFilename,\n      filename: opts.filename,\n      chunkName: fileNameToChunkName(opts.root, extractedFilename),\n    }\n  }\n}\n\nfunction codeFrameError(\n  code: string,\n  loc:\n    | {\n        start: { line: number; column: number }\n        end: { line: number; column: number }\n      }\n    | undefined\n    | null,\n  message: string,\n) {\n  if (!loc) {\n    return new Error(`${message} at unknown location`)\n  }\n\n  const frame = codeFrameColumns(\n    code,\n    {\n      start: loc.start,\n      end: loc.end,\n    },\n    {\n      highlightCode: true,\n      message,\n    },\n  )\n\n  return new Error(frame)\n}\n\nconst safeRemoveExports = (ast: babel.types.File) => {\n  const programBody = ast.program.body\n\n  const removeExport = (\n    path:\n      | babel.NodePath<babel.types.ExportDefaultDeclaration>\n      | babel.NodePath<babel.types.ExportNamedDeclaration>,\n  ) => {\n    // If the value is a function declaration, class declaration, or variable declaration,\n    // That means it has a name and can remain in the file, just unexported.\n    if (\n      babel.types.isFunctionDeclaration(path.node.declaration) ||\n      babel.types.isClassDeclaration(path.node.declaration) ||\n      babel.types.isVariableDeclaration(path.node.declaration)\n    ) {\n      // If the value is a function declaration, class declaration, or variable declaration,\n      // That means it has a name and can remain in the file, just unexported.\n      if (\n        babel.types.isFunctionDeclaration(path.node.declaration) ||\n        babel.types.isClassDeclaration(path.node.declaration) ||\n        babel.types.isVariableDeclaration(path.node.declaration)\n      ) {\n        // Move the declaration to the top level at the same index\n        const insertIndex = programBody.findIndex(\n          (node) => node === path.node.declaration,\n        )\n        // do not remove export if it is an anonymous function / class, otherwise this would produce a syntax error\n        if (\n          babel.types.isFunctionDeclaration(path.node.declaration) ||\n          babel.types.isClassDeclaration(path.node.declaration)\n        ) {\n          if (!path.node.declaration.id) {\n            return\n          }\n        }\n        programBody.splice(insertIndex, 0, path.node.declaration as any)\n      }\n    }\n\n    // Otherwise, remove the export declaration\n    path.remove()\n  }\n\n  // Before we add our export, remove any other exports.\n  // Don't remove the thing they export, just the export declaration\n  babel.traverse(ast, {\n    ExportDefaultDeclaration(path) {\n      removeExport(path)\n    },\n    ExportNamedDeclaration(path) {\n      removeExport(path)\n    },\n  })\n}\n\nfunction fileNameToChunkName(root: string, fileName: string) {\n  // Replace anything that can't go into an import statement\n  return fileName.replace(root, '').replace(/[^a-zA-Z0-9_]/g, '_')\n}\n"],"names":["functionName"],"mappings":"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"}