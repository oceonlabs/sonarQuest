{"version":3,"file":"createMiddleware.js","sources":["../../src/createMiddleware.ts"],"sourcesContent":["import type { StartInstanceOptions } from './createStart'\nimport type { AnyServerFn, ConstrainValidator, Method } from './createServerFn'\nimport type {\n  AnyContext,\n  Assign,\n  Constrain,\n  Expand,\n  IntersectAssign,\n  Register,\n  ResolveValidatorInput,\n  ResolveValidatorOutput,\n  ValidateSerializableInput,\n} from '@tanstack/router-core'\n\nexport type CreateMiddlewareFn<TRegister> = <TType extends MiddlewareType>(\n  options?: {\n    type?: TType\n  },\n  __opts?: FunctionMiddlewareOptions<\n    TRegister,\n    unknown,\n    undefined,\n    undefined,\n    undefined\n  >,\n) => CreateMiddlewareResult<TRegister, TType>\n\nexport const createMiddleware: CreateMiddlewareFn<{}> = (options, __opts) => {\n  const resolvedOptions = {\n    type: 'request',\n    ...(__opts || options),\n  }\n\n  return {\n    options: resolvedOptions,\n    middleware: (middleware: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    inputValidator: (inputValidator: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { inputValidator }),\n      ) as any\n    },\n    client: (client: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { client }),\n      ) as any\n    },\n    server: (server: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { server }),\n      ) as any\n    },\n  } as any\n}\n\nexport type MiddlewareType = 'request' | 'function'\n\nexport type CreateMiddlewareResult<\n  TRegister,\n  TType extends MiddlewareType,\n> = 'request' extends TType\n  ? RequestMiddleware<TRegister>\n  : FunctionMiddleware<TRegister>\n\nexport interface FunctionMiddleware<TRegister>\n  extends FunctionMiddlewareAfterMiddleware<TRegister, unknown> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<\n      TNewMiddlewares,\n      ReadonlyArray<AnyRequestMiddleware | AnyFunctionMiddleware>\n    >,\n  ) => FunctionMiddlewareAfterMiddleware<TRegister, TNewMiddlewares>\n}\n\nexport interface FunctionMiddlewareAfterMiddleware<TRegister, TMiddlewares>\n  extends FunctionMiddlewareWithTypes<\n      TRegister,\n      TMiddlewares,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined\n    >,\n    FunctionMiddlewareServer<\n      TRegister,\n      TMiddlewares,\n      undefined,\n      undefined,\n      undefined\n    >,\n    FunctionMiddlewareClient<TRegister, TMiddlewares, undefined>,\n    FunctionMiddlewareValidator<TRegister, TMiddlewares> {}\n\nexport interface FunctionMiddlewareWithTypes<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TServerContext,\n  TServerSendContext,\n  TClientContext,\n  TClientSendContext,\n> {\n  _types: FunctionMiddlewareTypes<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerContext,\n    TServerSendContext,\n    TClientContext,\n    TClientSendContext\n  >\n  options: FunctionMiddlewareOptions<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerContext,\n    TClientContext\n  >\n}\n\nexport interface FunctionMiddlewareTypes<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TServerContext,\n  in out TServerSendContext,\n  in out TClientContext,\n  in out TClientSendContext,\n> {\n  type: 'function'\n  middlewares: TMiddlewares\n  input: ResolveValidatorInput<TInputValidator>\n  allInput: IntersectAllValidatorInputs<TMiddlewares, TInputValidator>\n  output: ResolveValidatorOutput<TInputValidator>\n  allOutput: IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>\n  clientContext: TClientContext\n  allClientContextBeforeNext: AssignAllClientContextBeforeNext<\n    TMiddlewares,\n    TClientContext\n  >\n  allClientContextAfterNext: AssignAllClientContextAfterNext<\n    TMiddlewares,\n    TClientContext,\n    TClientSendContext\n  >\n  serverContext: TServerContext\n  serverSendContext: TServerSendContext\n  allServerSendContext: AssignAllServerSendContext<\n    TMiddlewares,\n    TServerSendContext\n  >\n  allServerContext: AssignAllServerFnContext<\n    TRegister,\n    TMiddlewares,\n    TServerSendContext,\n    TServerContext\n  >\n  clientSendContext: TClientSendContext\n  allClientSendContext: AssignAllClientSendContext<\n    TMiddlewares,\n    TClientSendContext\n  >\n  inputValidator: TInputValidator\n}\n\n/**\n * Recursively resolve the input type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorInputs<TMiddlewares, TInputValidator> =\n  unknown extends TInputValidator\n    ? TInputValidator\n    : TInputValidator extends undefined\n      ? IntersectAllMiddleware<TMiddlewares, 'allInput'>\n      : IntersectAssign<\n          IntersectAllMiddleware<TMiddlewares, 'allInput'>,\n          ResolveValidatorInput<TInputValidator>\n        >\n\nexport type IntersectAllMiddleware<\n  TMiddlewares,\n  TType extends\n    | keyof AnyFunctionMiddleware['_types']\n    | keyof AnyRequestMiddleware['_types']\n    | keyof AnyServerFn['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [infer TMiddleware, ...infer TRest]\n  ? TMiddleware extends\n      | AnyFunctionMiddleware\n      | AnyRequestMiddleware\n      | AnyServerFn\n    ? IntersectAllMiddleware<\n        TRest,\n        TType,\n        IntersectAssign<\n          TAcc,\n          TMiddleware['_types'][TType & keyof TMiddleware['_types']]\n        >\n      >\n    : TAcc\n  : TAcc\n\nexport type AnyFunctionMiddleware = FunctionMiddlewareWithTypes<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * Recursively merge the output type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorOutputs<TMiddlewares, TInputValidator> =\n  unknown extends TInputValidator\n    ? TInputValidator\n    : TInputValidator extends undefined\n      ? IntersectAllMiddleware<TMiddlewares, 'allOutput'>\n      : IntersectAssign<\n          IntersectAllMiddleware<TMiddlewares, 'allOutput'>,\n          ResolveValidatorOutput<TInputValidator>\n        >\n\n/**\n * Recursively resolve the client context type produced by a sequence of middleware\n */\nexport type AssignAllClientContextBeforeNext<\n  TMiddlewares,\n  TClientContext = undefined,\n> = unknown extends TClientContext\n  ? TClientContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientContextBeforeNext'>,\n      TClientContext\n    >\n\nexport type AssignAllMiddleware<\n  TMiddlewares,\n  TType extends\n    | keyof AnyFunctionMiddleware['_types']\n    | keyof AnyRequestMiddleware['_types']\n    | keyof AnyServerFn['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [infer TMiddleware, ...infer TRest]\n  ? TMiddleware extends\n      | AnyFunctionMiddleware\n      | AnyRequestMiddleware\n      | AnyServerFn\n    ? AssignAllMiddleware<\n        TRest,\n        TType,\n        Assign<TAcc, TMiddleware['_types'][TType & keyof TMiddleware['_types']]>\n      >\n    : TAcc\n  : TAcc\n\nexport type AssignAllClientContextAfterNext<\n  TMiddlewares,\n  TClientContext = undefined,\n  TSendContext = undefined,\n> = unknown extends TClientContext\n  ? Assign<TClientContext, TSendContext>\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientContextAfterNext'>,\n      Assign<TClientContext, TSendContext>\n    >\n\nexport type AssignAllServerSendContext<\n  TMiddlewares,\n  TSendContext = undefined,\n> = unknown extends TSendContext\n  ? TSendContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allServerSendContext'>,\n      TSendContext\n    >\n\nexport type AssignAllServerRequestContext<\n  TRegister,\n  TMiddlewares,\n  TSendContext = undefined,\n  TServerContext = undefined,\n> = Assign<\n  // Fetch Request Context\n  GlobalFetchRequestContext,\n  // AnyContext,\n  Assign<\n    GlobalServerRequestContext<TRegister>, // TODO: This enabled global middleware\n    // type inference, but creates a circular types issue. No idea how to fix this.\n    // AnyContext,\n    __AssignAllServerRequestContext<TMiddlewares, TSendContext, TServerContext>\n  >\n>\n\n// export type GlobalFetchRequestContext<TRegister> = AnyContext\nexport type GlobalFetchRequestContext = Register extends {\n  server: { requestContext: infer TRequestContext }\n}\n  ? TRequestContext\n  : AnyContext\n\nexport type GlobalServerRequestContext<TRegister> = TRegister extends {\n  config: StartInstanceOptions<any, any, infer TRequestMiddlewares, any>\n}\n  ? AssignAllMiddleware<TRequestMiddlewares, 'allServerContext'>\n  : AnyContext\n\ntype __AssignAllServerRequestContext<\n  TMiddlewares,\n  TSendContext = undefined,\n  TServerContext = undefined,\n> = unknown extends TSendContext\n  ? Assign<TSendContext, TServerContext>\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allServerContext'>,\n      Assign<TSendContext, TServerContext>\n    >\n\nexport type AssignAllServerFnContext<\n  TRegister,\n  TMiddlewares,\n  TSendContext = undefined,\n  TServerContext = undefined,\n> = Assign<\n  GlobalFetchRequestContext,\n  Assign<\n    GlobalServerRequestContext<TRegister>, // TODO: This enabled global middleware\n    // type inference, but creates a circular types issue. No idea how to fix this.\n    // AnyContext,\n    Assign<\n      GlobalServerFnContext<TRegister>, // TODO: This enabled global middleware\n      // type inference, but creates a circular types issue. No idea how to fix this.\n      // AnyContext,/\n      __AssignAllServerFnContext<TMiddlewares, TSendContext, TServerContext>\n    >\n  >\n>\n\ntype GlobalServerFnContext<TRegister> = TRegister extends {\n  config: StartInstanceOptions<any, any, any, infer TFunctionMiddlewares>\n}\n  ? AssignAllMiddleware<TFunctionMiddlewares, 'allServerContext'>\n  : AnyContext\n\ntype __AssignAllServerFnContext<\n  TMiddlewares,\n  TSendContext = undefined,\n  TServerContext = undefined,\n> = unknown extends TSendContext\n  ? Assign<TSendContext, TServerContext>\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allServerContext'>,\n      Assign<TSendContext, TServerContext>\n    >\n\nexport type AssignAllClientSendContext<\n  TMiddlewares,\n  TSendContext = undefined,\n> = unknown extends TSendContext\n  ? TSendContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientSendContext'>,\n      TSendContext\n    >\n\nexport interface FunctionMiddlewareOptions<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TServerContext,\n  in out TClientContext,\n> {\n  middleware?: TMiddlewares\n  inputValidator?: ConstrainValidator<TRegister, 'GET', TInputValidator>\n  client?: FunctionMiddlewareClientFn<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerContext,\n    TClientContext\n  >\n  server?: FunctionMiddlewareServerFn<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerContext,\n    unknown,\n    unknown\n  >\n}\n\nexport type FunctionMiddlewareClientNextFn<TRegister, TMiddlewares> = <\n  TSendContext = undefined,\n  TNewClientContext = undefined,\n>(ctx?: {\n  context?: TNewClientContext\n  sendContext?: ValidateSerializableInput<TRegister, TSendContext>\n  headers?: HeadersInit\n}) => Promise<\n  FunctionClientResultWithContext<TMiddlewares, TSendContext, TNewClientContext>\n>\n\nexport interface FunctionMiddlewareServer<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TServerSendContext,\n  TClientContext,\n> {\n  server: <TNewServerContext = undefined, TSendContext = undefined>(\n    server: FunctionMiddlewareServerFn<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      TServerSendContext,\n      TNewServerContext,\n      TSendContext\n    >,\n  ) => FunctionMiddlewareAfterServer<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TNewServerContext,\n    TServerSendContext,\n    TClientContext,\n    TSendContext\n  >\n}\n\nexport type FunctionMiddlewareServerFn<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TServerSendContext,\n  TNewServerContext,\n  TSendContext,\n> = (\n  options: FunctionMiddlewareServerFnOptions<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerSendContext\n  >,\n) => FunctionMiddlewareServerFnResult<\n  TRegister,\n  TMiddlewares,\n  TServerSendContext,\n  TNewServerContext,\n  TSendContext\n>\n\nexport type FunctionMiddlewareServerNextFn<\n  TRegister,\n  TMiddlewares,\n  TServerSendContext,\n> = <TNewServerContext = undefined, TSendContext = undefined>(ctx?: {\n  context?: TNewServerContext\n  sendContext?: ValidateSerializableInput<TRegister, TSendContext>\n}) => Promise<\n  FunctionServerResultWithContext<\n    TRegister,\n    TMiddlewares,\n    TServerSendContext,\n    TNewServerContext,\n    TSendContext\n  >\n>\n\nexport type FunctionServerResultWithContext<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TServerSendContext,\n  in out TServerContext,\n  in out TSendContext,\n> = {\n  'use functions must return the result of next()': true\n  _types: {\n    context: TServerContext\n    sendContext: TSendContext\n  }\n  context: Expand<\n    AssignAllServerFnContext<\n      TRegister,\n      TMiddlewares,\n      TServerSendContext,\n      TServerContext\n    >\n  >\n  sendContext: Expand<AssignAllClientSendContext<TMiddlewares, TSendContext>>\n}\n\nexport interface FunctionMiddlewareServerFnOptions<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TServerSendContext,\n> {\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>>\n  context: Expand<\n    AssignAllServerFnContext<TRegister, TMiddlewares, TServerSendContext>\n  >\n  next: FunctionMiddlewareServerNextFn<\n    TRegister,\n    TMiddlewares,\n    TServerSendContext\n  >\n  method: Method\n  filename: string\n  functionId: string\n  signal: AbortSignal\n}\n\nexport type FunctionMiddlewareServerFnResult<\n  TRegister,\n  TMiddlewares,\n  TServerSendContext,\n  TServerContext,\n  TSendContext,\n> =\n  | Promise<\n      FunctionServerResultWithContext<\n        TRegister,\n        TMiddlewares,\n        TServerSendContext,\n        TServerContext,\n        TSendContext\n      >\n    >\n  | FunctionServerResultWithContext<\n      TRegister,\n      TMiddlewares,\n      TServerSendContext,\n      TServerContext,\n      TSendContext\n    >\n\nexport interface FunctionMiddlewareAfterServer<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TServerContext,\n  TServerSendContext,\n  TClientContext,\n  TClientSendContext,\n> extends FunctionMiddlewareWithTypes<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TServerContext,\n    TServerSendContext,\n    TClientContext,\n    TClientSendContext\n  > {}\n\nexport interface FunctionMiddlewareClient<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n> {\n  client: <TSendServerContext = undefined, TNewClientContext = undefined>(\n    client: FunctionMiddlewareClientFn<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      TSendServerContext,\n      TNewClientContext\n    >,\n  ) => FunctionMiddlewareAfterClient<\n    TRegister,\n    TMiddlewares,\n    TInputValidator,\n    TSendServerContext,\n    TNewClientContext\n  >\n}\n\nexport type FunctionMiddlewareClientFn<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TSendContext,\n  TClientContext,\n> = (\n  options: FunctionMiddlewareClientFnOptions<\n    TRegister,\n    TMiddlewares,\n    TInputValidator\n  >,\n) => FunctionMiddlewareClientFnResult<\n  TMiddlewares,\n  TSendContext,\n  TClientContext\n>\n\nexport interface FunctionMiddlewareClientFnOptions<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TInputValidator,\n> {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TInputValidator>>\n  context: Expand<AssignAllClientContextBeforeNext<TMiddlewares>>\n  sendContext: Expand<AssignAllServerSendContext<TMiddlewares>>\n  method: Method\n  signal: AbortSignal\n  next: FunctionMiddlewareClientNextFn<TRegister, TMiddlewares>\n  filename: string\n  functionId: string\n}\n\nexport type FunctionMiddlewareClientFnResult<\n  TMiddlewares,\n  TSendContext,\n  TClientContext,\n> =\n  | Promise<\n      FunctionClientResultWithContext<\n        TMiddlewares,\n        TSendContext,\n        TClientContext\n      >\n    >\n  | FunctionClientResultWithContext<TMiddlewares, TSendContext, TClientContext>\n\nexport type FunctionClientResultWithContext<\n  in out TMiddlewares,\n  in out TSendContext,\n  in out TClientContext,\n> = {\n  'use functions must return the result of next()': true\n  context: Expand<AssignAllClientContextAfterNext<TMiddlewares, TClientContext>>\n  sendContext: Expand<AssignAllServerSendContext<TMiddlewares, TSendContext>>\n  headers: HeadersInit\n}\n\nexport interface FunctionMiddlewareAfterClient<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TServerSendContext,\n  TClientContext,\n> extends FunctionMiddlewareWithTypes<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      undefined,\n      TServerSendContext,\n      TClientContext,\n      undefined\n    >,\n    FunctionMiddlewareServer<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      TServerSendContext,\n      TClientContext\n    > {}\n\nexport interface FunctionMiddlewareValidator<TRegister, TMiddlewares> {\n  inputValidator: <TNewValidator>(\n    inputValidator: ConstrainValidator<TRegister, 'GET', TNewValidator>,\n  ) => FunctionMiddlewareAfterValidator<TRegister, TMiddlewares, TNewValidator>\n}\n\nexport interface FunctionMiddlewareAfterValidator<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n> extends FunctionMiddlewareWithTypes<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      undefined,\n      undefined,\n      undefined,\n      undefined\n    >,\n    FunctionMiddlewareServer<\n      TRegister,\n      TMiddlewares,\n      TInputValidator,\n      undefined,\n      undefined\n    >,\n    FunctionMiddlewareClient<TRegister, TMiddlewares, TInputValidator> {}\n\nexport interface RequestMiddleware<TRegister>\n  extends RequestMiddlewareAfterMiddleware<TRegister, undefined> {\n  middleware: <const TMiddlewares = undefined>(\n    middlewares: Constrain<TMiddlewares, ReadonlyArray<AnyRequestMiddleware>>,\n  ) => RequestMiddlewareAfterMiddleware<TRegister, TMiddlewares>\n}\n\nexport type AnyRequestMiddleware = RequestMiddlewareWithTypes<any, any, any>\n\nexport interface RequestMiddlewareWithTypes<\n  TRegister,\n  TMiddlewares,\n  TServerContext,\n> {\n  _types: RequestMiddlewareTypes<TRegister, TMiddlewares, TServerContext>\n  options: RequestMiddlewareOptions<TRegister, TMiddlewares, TServerContext>\n}\n\nexport interface RequestMiddlewareOptions<\n  in out TRegister,\n  in out TMiddlewares,\n  in out TServerContext,\n> {\n  middleware?: TMiddlewares\n  server?: RequestServerFn<TRegister, TMiddlewares, TServerContext>\n}\nexport interface RequestMiddlewareTypes<\n  TRegister,\n  TMiddlewares,\n  TServerContext,\n> {\n  type: 'request'\n  middlewares: TMiddlewares\n  serverContext: TServerContext\n  allServerContext: AssignAllServerRequestContext<\n    TRegister,\n    TMiddlewares,\n    undefined,\n    TServerContext\n  >\n}\n\nexport interface RequestMiddlewareAfterMiddleware<TRegister, TMiddlewares>\n  extends RequestMiddlewareWithTypes<TRegister, TMiddlewares, undefined>,\n    RequestMiddlewareServer<TRegister, TMiddlewares> {}\n\nexport interface RequestMiddlewareServer<TRegister, TMiddlewares> {\n  server: <TServerContext = undefined>(\n    fn: RequestServerFn<TRegister, TMiddlewares, TServerContext>,\n  ) => RequestMiddlewareAfterServer<TRegister, TMiddlewares, TServerContext>\n}\n\nexport type RequestServerFn<TRegister, TMiddlewares, TServerContext> = (\n  options: RequestServerOptions<TRegister, TMiddlewares>,\n) => RequestMiddlewareServerFnResult<TRegister, TMiddlewares, TServerContext>\n\nexport interface RequestServerOptions<TRegister, TMiddlewares> {\n  request: Request\n  pathname: string\n  context: Expand<AssignAllServerRequestContext<TRegister, TMiddlewares>>\n  next: RequestServerNextFn<TRegister, TMiddlewares>\n}\n\nexport type RequestServerNextFn<TRegister, TMiddlewares> = <\n  TServerContext = undefined,\n>(\n  options?: RequestServerNextFnOptions<TServerContext>,\n) => RequestMiddlewareServerFnResult<TRegister, TMiddlewares, TServerContext>\n\nexport interface RequestServerNextFnOptions<TServerContext> {\n  context?: TServerContext\n}\n\nexport type RequestMiddlewareServerFnResult<\n  TRegister,\n  TMiddlewares,\n  TServerContext,\n> =\n  | Promise<RequestServerResult<TRegister, TMiddlewares, TServerContext>>\n  | RequestServerResult<TRegister, TMiddlewares, TServerContext>\n\nexport interface RequestServerResult<TRegister, TMiddlewares, TServerContext> {\n  request: Request\n  pathname: string\n  context: Expand<\n    AssignAllServerRequestContext<\n      TRegister,\n      TMiddlewares,\n      undefined,\n      TServerContext\n    >\n  >\n  response: Response\n}\n\nexport interface RequestMiddlewareAfterServer<\n  TRegister,\n  TMiddlewares,\n  TServerContext,\n> extends RequestMiddlewareWithTypes<TRegister, TMiddlewares, TServerContext> {}\n"],"names":[],"mappings":"AA2BO,MAAM,mBAA2C,CAAC,SAAS,WAAW;AAC3E,QAAM,kBAAkB;AAAA,IACtB,MAAM;AAAA,IACN,GAAI,UAAU;AAAA,EAAA;AAGhB,SAAO;AAAA,IACL,SAAS;AAAA,IACT,YAAY,CAAC,eAAoB;AAC/B,aAAO;AAAA,QACL,CAAA;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,YAAY;AAAA,MAAA;AAAA,IAEjD;AAAA,IACA,gBAAgB,CAAC,mBAAwB;AACvC,aAAO;AAAA,QACL,CAAA;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,gBAAgB;AAAA,MAAA;AAAA,IAErD;AAAA,IACA,QAAQ,CAAC,WAAgB;AACvB,aAAO;AAAA,QACL,CAAA;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,QAAQ;AAAA,MAAA;AAAA,IAE7C;AAAA,IACA,QAAQ,CAAC,WAAgB;AACvB,aAAO;AAAA,QACL,CAAA;AAAA,QACA,OAAO,OAAO,iBAAiB,EAAE,QAAQ;AAAA,MAAA;AAAA,IAE7C;AAAA,EAAA;AAEJ;"}