{"version":3,"file":"createServerFn.js","sources":["../../src/createServerFn.ts"],"sourcesContent":["import { isNotFound, isRedirect } from '@tanstack/router-core'\nimport { mergeHeaders } from '@tanstack/router-core/ssr/client'\n\nimport { TSS_SERVER_FUNCTION_FACTORY } from './constants'\nimport { getServerContextAfterGlobalMiddlewares } from './getServerContextAfterGlobalMiddlewares'\nimport { getStartOptions } from './getStartOptions'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  Register,\n  RegisteredSerializableInput,\n  ResolveValidatorInput,\n  ValidateSerializable,\n  ValidateSerializableInput,\n  ValidateSerializableInputResult,\n  Validator,\n} from '@tanstack/router-core'\nimport type { JsonResponse } from '@tanstack/router-core/ssr/client'\nimport type {\n  AnyFunctionMiddleware,\n  AnyRequestMiddleware,\n  AssignAllServerFnContext,\n  FunctionMiddlewareClientFnResult,\n  FunctionMiddlewareServerFnResult,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n} from './createMiddleware'\n\ntype TODO = any\n\nexport type CreateServerFn<TRegister> = <\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TInputValidator = undefined,\n>(\n  options?: {\n    method?: TMethod\n  },\n  __opts?: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TInputValidator\n  >,\n) => ServerFnBuilder<TRegister, TMethod>\n\nexport const createServerFn: CreateServerFn<Register> = (options, __opts) => {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as Method\n  }\n\n  const res: ServerFnBuilder<Register, Method> = {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      // multiple calls to `middleware()` merge the middlewares with the previously supplied ones\n      // this is primarily useful for letting users create their own abstractions on top of `createServerFn`\n\n      const newMiddleware = [...(resolvedOptions.middleware || [])]\n      middleware.map((m) => {\n        if (TSS_SERVER_FUNCTION_FACTORY in m) {\n          if (m.options.middleware) {\n            newMiddleware.push(...m.options.middleware)\n          }\n        } else {\n          newMiddleware.push(m)\n        }\n      })\n\n      const newOptions = {\n        ...resolvedOptions,\n        middleware: newMiddleware,\n      }\n      const res = createServerFn(undefined, newOptions) as any\n      res[TSS_SERVER_FUNCTION_FACTORY] = true\n      return res\n    },\n    inputValidator: (inputValidator) => {\n      const newOptions = { ...resolvedOptions, inputValidator }\n      return createServerFn(undefined, newOptions) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<Register, any>,\n        ServerFn<Register, Method, any, any, any>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      const newOptions = { ...resolvedOptions, extractedFn, serverFn }\n\n      const resolvedMiddleware = [\n        ...(newOptions.middleware || []),\n        serverFnBaseToMiddleware(newOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            ...newOptions,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            signal: opts?.signal,\n            context: {},\n          }).then((d) => {\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts: any, signal: AbortSignal) => {\n            const serverContextAfterGlobalMiddlewares =\n              getServerContextAfterGlobalMiddlewares()\n            const ctx = {\n              ...extractedFn,\n              ...opts,\n              context: {\n                ...serverContextAfterGlobalMiddlewares,\n                ...opts.context,\n              },\n              signal,\n            }\n\n            return executeMiddleware(resolvedMiddleware, 'server', ctx).then(\n              (d) => ({\n                // Only send the result and sendContext back to the client\n                result: d.result,\n                error: d.error,\n                context: d.sendContext,\n              }),\n            )\n          },\n        },\n      ) as any\n    },\n  } as ServerFnBuilder<Register, Method>\n  const fun = (options?: { method?: Method }) => {\n    return {\n      ...res,\n      options: {\n        ...res.options,\n        ...options,\n      },\n    }\n  }\n  return Object.assign(fun, res) as any\n}\n\nexport async function executeMiddleware(\n  middlewares: Array<AnyFunctionMiddleware | AnyRequestMiddleware>,\n  env: 'client' | 'server',\n  opts: ServerFnMiddlewareOptions,\n): Promise<ServerFnMiddlewareResult> {\n  const globalMiddlewares = getStartOptions().functionMiddleware || []\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddlewares,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      'inputValidator' in nextMiddleware.options &&\n      nextMiddleware.options.inputValidator &&\n      env === 'server'\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(\n        nextMiddleware.options.inputValidator,\n        ctx.data,\n      )\n    }\n\n    const middlewareFn = (\n      env === 'client' && 'client' in nextMiddleware.options\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        return next(newCtx).catch((error: any) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  signal?: AbortSignal\n  context?: any\n}\n\nexport type Fetcher<TRegister, TMiddlewares, TInputValidator, TResponse> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TInputValidator>\n    ? OptionalFetcher<TRegister, TMiddlewares, TInputValidator, TResponse>\n    : RequiredFetcher<TRegister, TMiddlewares, TInputValidator, TResponse>\n\nexport interface FetcherBase {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n    signal: AbortSignal\n  }) => Promise<unknown>\n}\n\nexport interface OptionalFetcher<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TResponse,\n> extends FetcherBase {\n  (\n    options?: OptionalFetcherDataOptions<TMiddlewares, TInputValidator>,\n  ): Promise<FetcherData<TRegister, TResponse>>\n}\n\nexport interface RequiredFetcher<\n  TRegister,\n  TMiddlewares,\n  TInputValidator,\n  TResponse,\n> extends FetcherBase {\n  (\n    opts: RequiredFetcherDataOptions<TMiddlewares, TInputValidator>,\n  ): Promise<FetcherData<TRegister, TResponse>>\n}\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n  signal?: AbortSignal\n}\n\nexport interface OptionalFetcherDataOptions<TMiddlewares, TInputValidator>\n  extends FetcherBaseOptions {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TInputValidator>>\n}\n\nexport interface RequiredFetcherDataOptions<TMiddlewares, TInputValidator>\n  extends FetcherBaseOptions {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TInputValidator>>\n}\n\nexport type FetcherData<TRegister, TResponse> = TResponse extends Response\n  ? Response\n  : TResponse extends JsonResponse<any>\n    ? ValidateSerializableInputResult<TRegister, ReturnType<TResponse['json']>>\n    : ValidateSerializableInputResult<TRegister, TResponse>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFnReturnType<TRegister, TResponse> =\n  | Response\n  | Promise<ValidateSerializableInput<TRegister, TResponse>>\n  | ValidateSerializableInput<TRegister, TResponse>\n\nexport type ServerFn<\n  TRegister,\n  TMethod,\n  TMiddlewares,\n  TInputValidator,\n  TResponse,\n> = (\n  ctx: ServerFnCtx<TRegister, TMethod, TMiddlewares, TInputValidator>,\n) => ServerFnReturnType<TRegister, TResponse>\n\nexport interface ServerFnCtx<\n  TRegister,\n  TMethod,\n  TMiddlewares,\n  TInputValidator,\n> {\n  method: TMethod\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>>\n  context: Expand<AssignAllServerFnContext<TRegister, TMiddlewares, {}>>\n  signal: AbortSignal\n}\n\nexport type CompiledFetcherFn<TRegister, TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<TRegister, Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\nexport type ServerFnBaseOptions<\n  TRegister,\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInputValidator = unknown,\n> = {\n  method: TMethod\n  middleware?: Constrain<\n    TMiddlewares,\n    ReadonlyArray<AnyFunctionMiddleware | AnyRequestMiddleware>\n  >\n  inputValidator?: ConstrainValidator<TRegister, TMethod, TInputValidator>\n  extractedFn?: CompiledFetcherFn<TRegister, TResponse>\n  serverFn?: ServerFn<\n    TRegister,\n    TMethod,\n    TMiddlewares,\n    TInputValidator,\n    TResponse\n  >\n  functionId: string\n}\n\nexport type ValidateValidatorInput<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> = TMethod extends 'POST'\n  ? ResolveValidatorInput<TInputValidator> extends FormData\n    ? ResolveValidatorInput<TInputValidator>\n    : ValidateSerializable<\n        ResolveValidatorInput<TInputValidator>,\n        RegisteredSerializableInput<TRegister>\n      >\n  : ValidateSerializable<\n      ResolveValidatorInput<TInputValidator>,\n      RegisteredSerializableInput<TRegister>\n    >\n\nexport type ValidateValidator<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> =\n  ValidateValidatorInput<\n    TRegister,\n    TMethod,\n    TInputValidator\n  > extends infer TInput\n    ? Validator<TInput, any>\n    : never\n\nexport type ConstrainValidator<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> =\n  | (unknown extends TInputValidator\n      ? TInputValidator\n      : ResolveValidatorInput<TInputValidator> extends ValidateValidator<\n            TRegister,\n            TMethod,\n            TInputValidator\n          >\n        ? TInputValidator\n        : never)\n  | ValidateValidator<TRegister, TMethod, TInputValidator>\n\nexport type AppendMiddlewares<TMiddlewares, TNewMiddlewares> =\n  TMiddlewares extends ReadonlyArray<any>\n    ? TNewMiddlewares extends ReadonlyArray<any>\n      ? readonly [...TMiddlewares, ...TNewMiddlewares]\n      : TMiddlewares\n    : TNewMiddlewares\n\nexport interface ServerFnMiddleware<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> {\n  middleware: <const TNewMiddlewares>(\n    middlewares: Constrain<\n      TNewMiddlewares,\n      ReadonlyArray<AnyFunctionMiddleware | AnyRequestMiddleware | AnyServerFn>\n    >,\n  ) => ServerFnAfterMiddleware<\n    TRegister,\n    TMethod,\n    AppendMiddlewares<TMiddlewares, TNewMiddlewares>,\n    TInputValidator\n  >\n}\n\nexport interface ServerFnAfterMiddleware<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, TMiddlewares, undefined>,\n    ServerFnValidator<TRegister, TMethod, TMiddlewares>,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {\n  <TNewMethod extends Method = TMethod>(options?: {\n    method?: TNewMethod\n  }): ServerFnAfterMiddleware<\n    TRegister,\n    TNewMethod,\n    TMiddlewares,\n    TInputValidator\n  >\n}\n\nexport type ValidatorFn<TRegister, TMethod extends Method, TMiddlewares> = <\n  TInputValidator,\n>(\n  inputValidator: ConstrainValidator<TRegister, TMethod, TInputValidator>,\n) => ServerFnAfterValidator<TRegister, TMethod, TMiddlewares, TInputValidator>\n\nexport interface ServerFnValidator<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n> {\n  inputValidator: ValidatorFn<TRegister, TMethod, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, TMiddlewares, TInputValidator>,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {}\n\nexport interface ServerFnAfterTyper<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {}\n\n// Handler\nexport interface ServerFnHandler<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      TNewResponse\n    >,\n  ) => Fetcher<TRegister, TMiddlewares, TInputValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<TRegister, TMethod extends Method = 'GET'>\n  extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      undefined,\n      undefined,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, undefined, undefined>,\n    ServerFnValidator<TRegister, TMethod, undefined>,\n    ServerFnHandler<TRegister, TMethod, undefined, undefined> {\n  options: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    unknown,\n    undefined,\n    undefined\n  >\n}\n\nexport interface ServerFnWithTypes<\n  in out TRegister,\n  in out TMethod extends Method,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TResponse,\n> {\n  _types: ServerFnTypes<\n    TRegister,\n    TMethod,\n    TMiddlewares,\n    TInputValidator,\n    TResponse\n  >\n  options: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    unknown,\n    undefined,\n    undefined\n  >\n  [TSS_SERVER_FUNCTION_FACTORY]: true\n}\n\nexport type AnyServerFn = ServerFnWithTypes<any, any, any, any, any>\n\nexport interface ServerFnTypes<\n  in out TRegister,\n  in out TMethod extends Method,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TResponse,\n> {\n  method: TMethod\n  middlewares: TMiddlewares\n  inputValidator: TInputValidator\n  response: TResponse\n  allServerContext: AssignAllServerFnContext<TRegister, TMiddlewares>\n  allInput: IntersectAllValidatorInputs<TMiddlewares, TInputValidator>\n  allOutput: IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>\n}\n\nexport function flattenMiddlewares(\n  middlewares: Array<AnyFunctionMiddleware | AnyRequestMiddleware>,\n): Array<AnyFunctionMiddleware | AnyRequestMiddleware> {\n  const seen = new Set<AnyFunctionMiddleware | AnyRequestMiddleware>()\n  const flattened: Array<AnyFunctionMiddleware | AnyRequestMiddleware> = []\n\n  const recurse = (\n    middleware: Array<AnyFunctionMiddleware | AnyRequestMiddleware>,\n  ) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type ServerFnMiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  signal?: AbortSignal\n  sendContext?: any\n  context?: any\n  functionId: string\n}\n\nexport type ServerFnMiddlewareResult = ServerFnMiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n}\n\nexport type NextFn = (\n  ctx: ServerFnMiddlewareResult,\n) => Promise<ServerFnMiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: ServerFnMiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<ServerFnMiddlewareResult>\n\nexport const applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: ServerFnMiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (\n      userCtx: ServerFnMiddlewareResult | undefined = {} as any,\n    ) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined\n            ? userCtx.result\n            : userCtx instanceof Response\n              ? userCtx\n              : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  } as any)\n}\n\nexport function execValidator(\n  validator: AnyValidator,\n  input: unknown,\n): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any, any>,\n): AnyFunctionMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      inputValidator: options.inputValidator,\n      client: async ({ next, sendContext, ...ctx }) => {\n        const payload = {\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        } as any\n\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.(payload)\n\n        return next(res) as unknown as FunctionMiddlewareClientFnResult<\n          any,\n          any,\n          any\n        >\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx as TODO)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as FunctionMiddlewareServerFnResult<\n          any,\n          any,\n          any,\n          any,\n          any\n        >\n      },\n    },\n  }\n}\n"],"names":["res","options"],"mappings":"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"}