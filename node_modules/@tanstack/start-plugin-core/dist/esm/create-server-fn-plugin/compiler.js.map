{"version":3,"file":"compiler.js","sources":["../../../src/create-server-fn-plugin/compiler.ts"],"sourcesContent":["/* eslint-disable import/no-commonjs */\nimport * as t from '@babel/types'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport babel from '@babel/core'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { handleCreateServerFn } from './handleCreateServerFn'\nimport { handleCreateMiddleware } from './handleCreateMiddleware'\n\ntype Binding =\n  | {\n      type: 'import'\n      source: string\n      importedName: string\n      resolvedKind?: Kind\n    }\n  | {\n      type: 'var'\n      init: t.Expression | null\n      resolvedKind?: Kind\n    }\n\ntype ExportEntry =\n  | { tag: 'Normal'; name: string }\n  | { tag: 'Default'; name: string }\n  | { tag: 'Namespace'; name: string; targetId: string } // for `export * as ns from './x'`\n\ntype Kind = 'None' | `Root` | `Builder` | LookupKind\n\nexport type LookupKind = 'ServerFn' | 'Middleware'\n\nconst LookupSetup: Record<\n  LookupKind,\n  { candidateCallIdentifier: Set<string> }\n> = {\n  ServerFn: { candidateCallIdentifier: new Set(['handler']) },\n  Middleware: {\n    candidateCallIdentifier: new Set(['server', 'client', 'createMiddlewares']),\n  },\n}\n\nexport type LookupConfig = {\n  libName: string\n  rootExport: string\n}\ninterface ModuleInfo {\n  id: string\n  code: string\n  ast: ReturnType<typeof parseAst>\n  bindings: Map<string, Binding>\n  exports: Map<string, ExportEntry>\n}\n\nexport class ServerFnCompiler {\n  private moduleCache = new Map<string, ModuleInfo>()\n  private initialized = false\n  private validLookupKinds: Set<LookupKind>\n  constructor(\n    private options: {\n      env: 'client' | 'server'\n      lookupConfigurations: Array<LookupConfig>\n      lookupKinds: Set<LookupKind>\n      loadModule: (id: string) => Promise<void>\n      resolveId: (id: string, importer?: string) => Promise<string | null>\n    },\n  ) {\n    this.validLookupKinds = options.lookupKinds\n  }\n\n  private async init(id: string) {\n    await Promise.all(\n      this.options.lookupConfigurations.map(async (config) => {\n        const libId = await this.options.resolveId(config.libName, id)\n        if (!libId) {\n          throw new Error(`could not resolve \"${config.libName}\"`)\n        }\n        let rootModule = this.moduleCache.get(libId)\n        if (!rootModule) {\n          // insert root binding\n          rootModule = {\n            ast: null as any,\n            bindings: new Map(),\n            exports: new Map(),\n            code: '',\n            id: libId,\n          }\n          this.moduleCache.set(libId, rootModule)\n        }\n\n        rootModule.exports.set(config.rootExport, {\n          tag: 'Normal',\n          name: config.rootExport,\n        })\n        rootModule.exports.set('*', {\n          tag: 'Namespace',\n          name: config.rootExport,\n          targetId: libId,\n        })\n        rootModule.bindings.set(config.rootExport, {\n          type: 'var',\n          init: t.identifier(config.rootExport),\n          resolvedKind: `Root` satisfies Kind,\n        })\n        this.moduleCache.set(libId, rootModule)\n      }),\n    )\n\n    this.initialized = true\n  }\n\n  public ingestModule({ code, id }: { code: string; id: string }) {\n    const ast = parseAst({ code })\n\n    const bindings = new Map<string, Binding>()\n    const exports = new Map<string, ExportEntry>()\n\n    // we are only interested in top-level bindings, hence we don't traverse the AST\n    // instead we only iterate over the program body\n    for (const node of ast.program.body) {\n      if (t.isImportDeclaration(node)) {\n        const source = node.source.value\n        for (const s of node.specifiers) {\n          if (t.isImportSpecifier(s)) {\n            const importedName = t.isIdentifier(s.imported)\n              ? s.imported.name\n              : s.imported.value\n            bindings.set(s.local.name, { type: 'import', source, importedName })\n          } else if (t.isImportDefaultSpecifier(s)) {\n            bindings.set(s.local.name, {\n              type: 'import',\n              source,\n              importedName: 'default',\n            })\n          } else if (t.isImportNamespaceSpecifier(s)) {\n            bindings.set(s.local.name, {\n              type: 'import',\n              source,\n              importedName: '*',\n            })\n          }\n        }\n      } else if (t.isVariableDeclaration(node)) {\n        for (const decl of node.declarations) {\n          if (t.isIdentifier(decl.id)) {\n            bindings.set(decl.id.name, {\n              type: 'var',\n              init: decl.init ?? null,\n            })\n          }\n        }\n      } else if (t.isExportNamedDeclaration(node)) {\n        // export const foo = ...\n        if (node.declaration) {\n          if (t.isVariableDeclaration(node.declaration)) {\n            for (const d of node.declaration.declarations) {\n              if (t.isIdentifier(d.id)) {\n                exports.set(d.id.name, { tag: 'Normal', name: d.id.name })\n                bindings.set(d.id.name, { type: 'var', init: d.init ?? null })\n              }\n            }\n          }\n        }\n        for (const sp of node.specifiers) {\n          if (t.isExportNamespaceSpecifier(sp)) {\n            exports.set(sp.exported.name, {\n              tag: 'Namespace',\n              name: sp.exported.name,\n              targetId: node.source?.value || '',\n            })\n          }\n          // export { local as exported }\n          else if (t.isExportSpecifier(sp)) {\n            const local = sp.local.name\n            const exported = t.isIdentifier(sp.exported)\n              ? sp.exported.name\n              : sp.exported.value\n            exports.set(exported, { tag: 'Normal', name: local })\n          }\n        }\n      } else if (t.isExportDefaultDeclaration(node)) {\n        const d = node.declaration\n        if (t.isIdentifier(d)) {\n          exports.set('default', { tag: 'Default', name: d.name })\n        } else {\n          const synth = '__default_export__'\n          bindings.set(synth, { type: 'var', init: d as t.Expression })\n          exports.set('default', { tag: 'Default', name: synth })\n        }\n      }\n    }\n\n    const info: ModuleInfo = { code, id, ast, bindings, exports }\n    this.moduleCache.set(id, info)\n    return info\n  }\n\n  public invalidateModule(id: string) {\n    return this.moduleCache.delete(id)\n  }\n\n  public async compile({ code, id }: { code: string; id: string }) {\n    if (!this.initialized) {\n      await this.init(id)\n    }\n    const { bindings, ast } = this.ingestModule({ code, id })\n    const candidates = this.collectCandidates(bindings)\n    if (candidates.length === 0) {\n      // this hook will only be invoked if there is `.handler(` | `.server(` | `.client(` in the code,\n      // so not discovering a handler candidate is rather unlikely, but maybe possible?\n      return null\n    }\n\n    // let's find out which of the candidates are actually server functions\n    const toRewrite: Array<{\n      callExpression: t.CallExpression\n      kind: LookupKind\n    }> = []\n    for (const handler of candidates) {\n      const kind = await this.resolveExprKind(handler, id)\n      if (this.validLookupKinds.has(kind as LookupKind)) {\n        toRewrite.push({ callExpression: handler, kind: kind as LookupKind })\n      }\n    }\n    if (toRewrite.length === 0) {\n      return null\n    }\n\n    const pathsToRewrite: Array<{\n      nodePath: babel.NodePath<t.CallExpression>\n      kind: LookupKind\n    }> = []\n    babel.traverse(ast, {\n      CallExpression(path) {\n        const found = toRewrite.findIndex((h) => path.node === h.callExpression)\n        if (found !== -1) {\n          pathsToRewrite.push({ nodePath: path, kind: toRewrite[found]!.kind })\n          // delete from toRewrite\n          toRewrite.splice(found, 1)\n        }\n      },\n    })\n\n    if (toRewrite.length > 0) {\n      throw new Error(\n        `Internal error: could not find all paths to rewrite. please file an issue`,\n      )\n    }\n\n    const refIdents = findReferencedIdentifiers(ast)\n\n    pathsToRewrite.map((p) => {\n      if (p.kind === 'ServerFn') {\n        handleCreateServerFn(p.nodePath, { env: this.options.env, code })\n      } else {\n        handleCreateMiddleware(p.nodePath, { env: this.options.env })\n      }\n    })\n\n    deadCodeElimination(ast, refIdents)\n\n    return generateFromAst(ast, {\n      sourceMaps: true,\n      sourceFileName: id,\n      filename: id,\n    })\n  }\n\n  // collects all candidate CallExpressions at top-level\n  private collectCandidates(bindings: Map<string, Binding>) {\n    const candidates: Array<t.CallExpression> = []\n\n    for (const binding of bindings.values()) {\n      if (binding.type === 'var') {\n        const handler = isCandidateCallExpression(\n          binding.init,\n          this.validLookupKinds,\n        )\n        if (handler) {\n          candidates.push(handler)\n        }\n      }\n    }\n    return candidates\n  }\n\n  private async resolveIdentifierKind(\n    ident: string,\n    id: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    const info = await this.getModuleInfo(id)\n\n    const binding = info.bindings.get(ident)\n    if (!binding) {\n      return 'None'\n    }\n    if (binding.resolvedKind) {\n      return binding.resolvedKind\n    }\n\n    // TODO improve cycle detection? should we throw here instead of returning 'None'?\n    // prevent cycles\n    const vKey = `${id}:${ident}`\n    if (visited.has(vKey)) {\n      return 'None'\n    }\n    visited.add(vKey)\n\n    const resolvedKind = await this.resolveBindingKind(binding, id, visited)\n    binding.resolvedKind = resolvedKind\n    return resolvedKind\n  }\n\n  private async resolveBindingKind(\n    binding: Binding,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (binding.resolvedKind) {\n      return binding.resolvedKind\n    }\n    if (binding.type === 'import') {\n      const target = await this.options.resolveId(binding.source, fileId)\n      if (!target) {\n        return 'None'\n      }\n\n      const importedModule = await this.getModuleInfo(target)\n\n      const moduleExport = importedModule.exports.get(binding.importedName)\n      if (!moduleExport) {\n        return 'None'\n      }\n      const importedBinding = importedModule.bindings.get(moduleExport.name)\n      if (!importedBinding) {\n        return 'None'\n      }\n      if (importedBinding.resolvedKind) {\n        return importedBinding.resolvedKind\n      }\n\n      const resolvedKind = await this.resolveBindingKind(\n        importedBinding,\n        importedModule.id,\n        visited,\n      )\n      importedBinding.resolvedKind = resolvedKind\n      return resolvedKind\n    }\n\n    const resolvedKind = await this.resolveExprKind(\n      binding.init,\n      fileId,\n      visited,\n    )\n    binding.resolvedKind = resolvedKind\n    return resolvedKind\n  }\n\n  private async resolveExprKind(\n    expr: t.Expression | null,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (!expr) {\n      return 'None'\n    }\n\n    let result: Kind = 'None'\n\n    if (t.isCallExpression(expr)) {\n      if (!t.isExpression(expr.callee)) {\n        return 'None'\n      }\n      const calleeKind = await this.resolveCalleeKind(\n        expr.callee,\n        fileId,\n        visited,\n      )\n      if (calleeKind !== 'None') {\n        if (calleeKind === `Root` || calleeKind === `Builder`) {\n          return `Builder`\n        }\n        for (const kind of this.validLookupKinds) {\n          if (calleeKind === kind) {\n            return kind\n          }\n        }\n      }\n    } else if (t.isMemberExpression(expr) && t.isIdentifier(expr.property)) {\n      result = await this.resolveCalleeKind(expr.object, fileId, visited)\n    }\n\n    if (result === 'None' && t.isIdentifier(expr)) {\n      result = await this.resolveIdentifierKind(expr.name, fileId, visited)\n    }\n\n    if (result === 'None' && t.isTSAsExpression(expr)) {\n      result = await this.resolveExprKind(expr.expression, fileId, visited)\n    }\n    if (result === 'None' && t.isTSNonNullExpression(expr)) {\n      result = await this.resolveExprKind(expr.expression, fileId, visited)\n    }\n    if (result === 'None' && t.isParenthesizedExpression(expr)) {\n      result = await this.resolveExprKind(expr.expression, fileId, visited)\n    }\n\n    return result\n  }\n\n  private async resolveCalleeKind(\n    callee: t.Expression,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (t.isIdentifier(callee)) {\n      return this.resolveIdentifierKind(callee.name, fileId, visited)\n    }\n\n    if (t.isMemberExpression(callee) && t.isIdentifier(callee.property)) {\n      const prop = callee.property.name\n\n      if (\n        this.validLookupKinds.has('ServerFn') &&\n        LookupSetup['ServerFn'].candidateCallIdentifier.has(prop)\n      ) {\n        const base = await this.resolveExprKind(callee.object, fileId, visited)\n        if (base === 'Root' || base === 'Builder') {\n          return 'ServerFn'\n        }\n        return 'None'\n      } else if (\n        this.validLookupKinds.has('Middleware') &&\n        LookupSetup['Middleware'].candidateCallIdentifier.has(prop)\n      ) {\n        const base = await this.resolveExprKind(callee.object, fileId, visited)\n        if (base === 'Root' || base === 'Builder' || base === 'Middleware') {\n          return 'Middleware'\n        }\n        return 'None'\n      }\n      // Check if the object is a namespace import\n      if (t.isIdentifier(callee.object)) {\n        const info = await this.getModuleInfo(fileId)\n        const binding = info.bindings.get(callee.object.name)\n        if (\n          binding &&\n          binding.type === 'import' &&\n          binding.importedName === '*'\n        ) {\n          // resolve the property from the target module\n          const targetModuleId = await this.options.resolveId(\n            binding.source,\n            fileId,\n          )\n          if (targetModuleId) {\n            const targetModule = await this.getModuleInfo(targetModuleId)\n            const exportEntry = targetModule.exports.get(callee.property.name)\n            if (exportEntry) {\n              const exportedBinding = targetModule.bindings.get(\n                exportEntry.name,\n              )\n              if (exportedBinding) {\n                return await this.resolveBindingKind(\n                  exportedBinding,\n                  targetModule.id,\n                  visited,\n                )\n              }\n            }\n          } else {\n            return 'None'\n          }\n        }\n      }\n      return this.resolveExprKind(callee.object, fileId, visited)\n    }\n\n    // handle nested expressions\n    return this.resolveExprKind(callee, fileId, visited)\n  }\n\n  private async getModuleInfo(id: string) {\n    let cached = this.moduleCache.get(id)\n    if (cached) {\n      return cached\n    }\n\n    await this.options.loadModule(id)\n\n    cached = this.moduleCache.get(id)\n    if (!cached) {\n      throw new Error(`could not load module info for ${id}`)\n    }\n    return cached\n  }\n}\n\nfunction isCandidateCallExpression(\n  node: t.Node | null | undefined,\n  lookupKinds: Set<LookupKind>,\n): undefined | t.CallExpression {\n  if (!t.isCallExpression(node)) return undefined\n\n  const callee = node.callee\n  if (!t.isMemberExpression(callee) || !t.isIdentifier(callee.property)) {\n    return undefined\n  }\n  for (const kind of lookupKinds) {\n    if (LookupSetup[kind].candidateCallIdentifier.has(callee.property.name)) {\n      return node\n    }\n  }\n\n  return undefined\n}\n"],"names":["babel","resolvedKind"],"mappings":"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"}