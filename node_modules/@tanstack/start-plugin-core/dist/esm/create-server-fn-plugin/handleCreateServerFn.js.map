{"version":3,"file":"handleCreateServerFn.js","sources":["../../../src/create-server-fn-plugin/handleCreateServerFn.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport {\n  codeFrameError,\n  getRootCallExpression,\n} from '../start-compiler-plugin/utils'\nimport type * as babel from '@babel/core'\n\nexport function handleCreateServerFn(\n  path: babel.NodePath<t.CallExpression>,\n  opts: {\n    env: 'client' | 'server'\n    code: string\n  },\n) {\n  // Traverse the member expression and find the call expressions for\n  // the validator, handler, and middleware methods. Check to make sure they\n  // are children of the createServerFn call expression.\n\n  const validMethods = ['middleware', 'inputValidator', 'handler'] as const\n  type ValidMethods = (typeof validMethods)[number]\n  const callExpressionPaths: Record<\n    ValidMethods,\n    babel.NodePath<t.CallExpression> | null\n  > = {\n    middleware: null,\n    inputValidator: null,\n    handler: null,\n  }\n\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createServerFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  // Check if the call is assigned to a variable\n  if (!rootCallExpression.parentPath.isVariableDeclarator()) {\n    throw new Error('createServerFn must be assigned to a variable!')\n  }\n\n  // Get the identifier name of the variable\n  const variableDeclarator = rootCallExpression.parentPath.node\n  const existingVariableName = (variableDeclarator.id as t.Identifier).name\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property.name as ValidMethods\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (callExpressionPaths.inputValidator) {\n    const innerInputExpression =\n      callExpressionPaths.inputValidator.node.arguments[0]\n\n    if (!innerInputExpression) {\n      throw new Error(\n        'createServerFn().inputValidator() must be called with a validator!',\n      )\n    }\n\n    // If we're on the client, remove the validator call expression\n    if (opts.env === 'client') {\n      if (\n        t.isMemberExpression(callExpressionPaths.inputValidator.node.callee)\n      ) {\n        callExpressionPaths.inputValidator.replaceWith(\n          callExpressionPaths.inputValidator.node.callee.object,\n        )\n      }\n    }\n  }\n\n  // First, we need to move the handler function to a nested function call\n  // that is applied to the arguments passed to the server function.\n\n  const handlerFnPath = callExpressionPaths.handler?.get(\n    'arguments.0',\n  ) as babel.NodePath<any>\n\n  if (!callExpressionPaths.handler || !handlerFnPath.node) {\n    throw codeFrameError(\n      opts.code,\n      path.node.callee.loc!,\n      `createServerFn must be called with a \"handler\" property!`,\n    )\n  }\n\n  const handlerFn = handlerFnPath.node\n\n  // So, the way we do this is we give the handler function a way\n  // to access the serverFn ctx on the server via function scope.\n  // The 'use server' extracted function will be called with the\n  // payload from the client, then use the scoped serverFn ctx\n  // to execute the handler function.\n  // This way, we can do things like data and middleware validation\n  // in the __execute function without having to AST transform the\n  // handler function too much itself.\n\n  // .handler((optsOut, ctx) => {\n  //   return ((optsIn) => {\n  //     'use server'\n  //     ctx.__execute(handlerFn, optsIn)\n  //   })(optsOut)\n  // })\n\n  // If the handler function is an identifier and we're on the client, we need to\n  // remove the bound function from the file.\n  // If we're on the server, you can leave it, since it will get referenced\n  // as a second argument.\n\n  if (t.isIdentifier(handlerFn)) {\n    if (opts.env === 'client') {\n      // Find the binding for the handler function\n      const binding = handlerFnPath.scope.getBinding(handlerFn.name)\n      // Remove it\n      if (binding) {\n        binding.path.remove()\n      }\n    }\n    // If the env is server, just leave it alone\n  }\n\n  handlerFnPath.replaceWith(\n    t.arrowFunctionExpression(\n      [t.identifier('opts'), t.identifier('signal')],\n      t.blockStatement(\n        // Everything in here is server-only, since the client\n        // will strip out anything in the 'use server' directive.\n        [\n          t.returnStatement(\n            t.callExpression(\n              t.identifier(`${existingVariableName}.__executeServer`),\n              [t.identifier('opts'), t.identifier('signal')],\n            ),\n          ),\n        ],\n        [t.directive(t.directiveLiteral('use server'))],\n      ),\n    ),\n  )\n\n  if (opts.env === 'server') {\n    callExpressionPaths.handler.node.arguments.push(handlerFn)\n  }\n}\n"],"names":[],"mappings":";;AAOO,SAAS,qBACd,MACA,MAIA;AAKA,QAAM,eAAe,CAAC,cAAc,kBAAkB,SAAS;AAE/D,QAAM,sBAGF;AAAA,IACF,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,SAAS;AAAA,EAAA;AAGX,QAAM,qBAAqB,sBAAsB,IAAI;AASrD,MAAI,CAAC,mBAAmB,WAAW,wBAAwB;AACzD,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AAGA,QAAM,qBAAqB,mBAAmB,WAAW;AACzD,QAAM,uBAAwB,mBAAmB,GAAoB;AAErE,qBAAmB,SAAS;AAAA,IAC1B,iBAAiB,sBAAsB;AACrC,UAAI,EAAE,aAAa,qBAAqB,KAAK,QAAQ,GAAG;AACtD,cAAM,OAAO,qBAAqB,KAAK,SAAS;AAEhD,YACE,aAAa,SAAS,IAAI,KAC1B,qBAAqB,WAAW,oBAChC;AACA,8BAAoB,IAAI,IAAI,qBAAqB;AAAA,QACnD;AAAA,MACF;AAAA,IACF;AAAA,EAAA,CACD;AAED,MAAI,oBAAoB,gBAAgB;AACtC,UAAM,uBACJ,oBAAoB,eAAe,KAAK,UAAU,CAAC;AAErD,QAAI,CAAC,sBAAsB;AACzB,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAAA,IAEJ;AAGA,QAAI,KAAK,QAAQ,UAAU;AACzB,UACE,EAAE,mBAAmB,oBAAoB,eAAe,KAAK,MAAM,GACnE;AACA,4BAAoB,eAAe;AAAA,UACjC,oBAAoB,eAAe,KAAK,OAAO;AAAA,QAAA;AAAA,MAEnD;AAAA,IACF;AAAA,EACF;AAKA,QAAM,gBAAgB,oBAAoB,SAAS;AAAA,IACjD;AAAA,EAAA;AAGF,MAAI,CAAC,oBAAoB,WAAW,CAAC,cAAc,MAAM;AACvD,UAAM;AAAA,MACJ,KAAK;AAAA,MACL,KAAK,KAAK,OAAO;AAAA,MACjB;AAAA,IAAA;AAAA,EAEJ;AAEA,QAAM,YAAY,cAAc;AAuBhC,MAAI,EAAE,aAAa,SAAS,GAAG;AAC7B,QAAI,KAAK,QAAQ,UAAU;AAEzB,YAAM,UAAU,cAAc,MAAM,WAAW,UAAU,IAAI;AAE7D,UAAI,SAAS;AACX,gBAAQ,KAAK,OAAA;AAAA,MACf;AAAA,IACF;AAAA,EAEF;AAEA,gBAAc;AAAA,IACZ,EAAE;AAAA,MACA,CAAC,EAAE,WAAW,MAAM,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,MAC7C,EAAE;AAAA;AAAA;AAAA,QAGA;AAAA,UACE,EAAE;AAAA,YACA,EAAE;AAAA,cACA,EAAE,WAAW,GAAG,oBAAoB,kBAAkB;AAAA,cACtD,CAAC,EAAE,WAAW,MAAM,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,YAAA;AAAA,UAC/C;AAAA,QACF;AAAA,QAEF,CAAC,EAAE,UAAU,EAAE,iBAAiB,YAAY,CAAC,CAAC;AAAA,MAAA;AAAA,IAChD;AAAA,EACF;AAGF,MAAI,KAAK,QAAQ,UAAU;AACzB,wBAAoB,QAAQ,KAAK,UAAU,KAAK,SAAS;AAAA,EAC3D;AACF;"}