import { existsSync, rmSync, promises } from "node:fs";
import { pathToFileURL } from "node:url";
import os from "node:os";
import path from "pathe";
import { withBase, joinURL, withoutBase } from "ufo";
import { VITE_ENVIRONMENT_NAMES } from "./constants.js";
import { createLogger } from "./utils.js";
import { Queue } from "./queue.js";
async function prerender({
  startConfig,
  builder,
  serverBundle
}) {
  const logger = createLogger("prerender");
  logger.info("Prerendering pages...");
  if (startConfig.prerender?.enabled && !startConfig.pages.length) {
    startConfig.pages = [
      {
        path: "/"
      }
    ];
  }
  const serverEnv = builder.environments[VITE_ENVIRONMENT_NAMES.server];
  if (!serverEnv) {
    throw new Error(
      `Vite's "${VITE_ENVIRONMENT_NAMES.server}" environment not found`
    );
  }
  const clientEnv = builder.environments[VITE_ENVIRONMENT_NAMES.client];
  if (!clientEnv) {
    throw new Error(
      `Vite's "${VITE_ENVIRONMENT_NAMES.client}" environment not found`
    );
  }
  const outputDir = clientEnv.config.build.outDir;
  const entryFile = findEntryFileInBundle(serverBundle);
  let fullEntryFilePath = path.join(serverEnv.config.build.outDir, entryFile);
  process.env.TSS_PRERENDERING = "true";
  if (!existsSync(fullEntryFilePath)) {
    const bundleOutputDir = path.resolve(
      serverEnv.config.root,
      ".tanstack",
      "start",
      "prerender"
    );
    rmSync(bundleOutputDir, { recursive: true, force: true });
    await writeBundleToDisk({ bundle: serverBundle, outDir: bundleOutputDir });
    fullEntryFilePath = path.join(bundleOutputDir, entryFile);
  }
  const { default: serverEntrypoint } = await import(pathToFileURL(fullEntryFilePath).toString());
  function localFetch(path2, options) {
    const url = new URL(`http://localhost${path2}`);
    return serverEntrypoint.fetch(new Request(url, options));
  }
  try {
    const pages = await prerenderPages({ outputDir });
    logger.info(`Prerendered ${pages.length} pages:`);
    pages.forEach((page) => {
      logger.info(`- ${page}`);
    });
  } catch (error) {
    logger.error(error);
  }
  function extractLinks(html) {
    const linkRegex = /<a[^>]+href=["']([^"']+)["'][^>]*>/g;
    const links = [];
    let match;
    while ((match = linkRegex.exec(html)) !== null) {
      const href = match[1];
      if (href && (href.startsWith("/") || href.startsWith("./"))) {
        links.push(href);
      }
    }
    return links;
  }
  async function prerenderPages({ outputDir: outputDir2 }) {
    const seen = /* @__PURE__ */ new Set();
    const retriesByPath = /* @__PURE__ */ new Map();
    const concurrency = startConfig.prerender?.concurrency ?? os.cpus().length;
    logger.info(`Concurrency: ${concurrency}`);
    const queue = new Queue({ concurrency });
    startConfig.pages.forEach((page) => addCrawlPageTask(page));
    await queue.start();
    return Array.from(seen);
    function addCrawlPageTask(page) {
      if (seen.has(page.path)) return;
      seen.add(page.path);
      if (page.fromCrawl) {
        startConfig.pages.push(page);
      }
      if (!(page.prerender?.enabled ?? true)) return;
      if (startConfig.prerender?.filter && !startConfig.prerender.filter(page))
        return;
      const prerenderOptions = {
        ...startConfig.prerender,
        ...page.prerender
      };
      queue.add(async () => {
        logger.info(`Crawling: ${page.path}`);
        const retries = retriesByPath.get(page.path) || 0;
        try {
          const encodedRoute = encodeURI(page.path);
          const res = await localFetch(withBase(encodedRoute, TSS_APP_BASE), {
            headers: {
              ...prerenderOptions.headers
            }
          });
          if (!res.ok) {
            throw new Error(`Failed to fetch ${page.path}: ${res.statusText}`, {
              cause: res
            });
          }
          const cleanPagePath = (prerenderOptions.outputPath || page.path).split(/[?#]/)[0];
          const contentType = res.headers.get("content-type") || "";
          const isImplicitHTML = !cleanPagePath.endsWith(".html") && contentType.includes("html");
          const routeWithIndex = cleanPagePath.endsWith("/") ? cleanPagePath + "index" : cleanPagePath;
          const htmlPath = cleanPagePath.endsWith("/") || prerenderOptions.autoSubfolderIndex ? joinURL(cleanPagePath, "index.html") : cleanPagePath + ".html";
          const filename = withoutBase(
            isImplicitHTML ? htmlPath : routeWithIndex,
            TSS_APP_BASE
          );
          const html = await res.text();
          const filepath = path.join(outputDir2, filename);
          await promises.mkdir(path.dirname(filepath), {
            recursive: true
          });
          await promises.writeFile(filepath, html);
          const newPage = await prerenderOptions.onSuccess?.({ page, html });
          if (newPage) {
            Object.assign(page, newPage);
          }
          if (prerenderOptions.crawlLinks ?? true) {
            const links = extractLinks(html);
            for (const link of links) {
              addCrawlPageTask({ path: link, fromCrawl: true });
            }
          }
        } catch (error) {
          if (retries < (prerenderOptions.retryCount ?? 0)) {
            logger.warn(`Encountered error, retrying: ${page.path} in 500ms`);
            await new Promise(
              (resolve) => setTimeout(resolve, prerenderOptions.retryDelay)
            );
            retriesByPath.set(page.path, retries + 1);
            addCrawlPageTask(page);
          } else {
            if (prerenderOptions.failOnError ?? true) {
              throw error;
            }
          }
        }
      });
    }
  }
}
function findEntryFileInBundle(bundle) {
  let entryFile;
  for (const [_name, file] of Object.entries(bundle)) {
    if (file.type === "chunk") {
      if (file.isEntry) {
        if (entryFile !== void 0) {
          throw new Error(
            `Multiple entry points found. Only one entry point is allowed.`
          );
        }
        entryFile = file.fileName;
      }
    }
  }
  if (entryFile === void 0) {
    throw new Error(`No entry point found in the bundle.`);
  }
  return entryFile;
}
async function writeBundleToDisk({
  bundle,
  outDir
}) {
  for (const [fileName, asset] of Object.entries(bundle)) {
    const fullPath = path.join(outDir, fileName);
    const content = asset.type === "asset" ? asset.source : asset.code;
    await promises.mkdir(path.dirname(fullPath), { recursive: true });
    await promises.writeFile(fullPath, content);
  }
}
export {
  prerender,
  writeBundleToDisk
};
//# sourceMappingURL=prerender.js.map
