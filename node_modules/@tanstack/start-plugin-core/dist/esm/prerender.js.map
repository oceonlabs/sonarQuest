{"version":3,"file":"prerender.js","sources":["../../src/prerender.ts"],"sourcesContent":["import { existsSync, promises as fsp, rmSync } from 'node:fs'\nimport { pathToFileURL } from 'node:url'\nimport os from 'node:os'\nimport path from 'pathe'\nimport { joinURL, withBase, withoutBase } from 'ufo'\nimport { VITE_ENVIRONMENT_NAMES } from './constants'\nimport { createLogger } from './utils'\nimport { Queue } from './queue'\nimport type { Rollup, ViteBuilder } from 'vite'\nimport type { Page, TanStackStartOutputConfig } from './schema'\n\nexport async function prerender({\n  startConfig,\n  builder,\n  serverBundle,\n}: {\n  startConfig: TanStackStartOutputConfig\n  builder: ViteBuilder\n  serverBundle: Rollup.OutputBundle\n}) {\n  const logger = createLogger('prerender')\n  logger.info('Prerendering pages...')\n\n  // If prerender is enabled but no pages are provided, default to prerendering the root page\n  if (startConfig.prerender?.enabled && !startConfig.pages.length) {\n    startConfig.pages = [\n      {\n        path: '/',\n      },\n    ]\n  }\n\n  const serverEnv = builder.environments[VITE_ENVIRONMENT_NAMES.server]\n\n  if (!serverEnv) {\n    throw new Error(\n      `Vite's \"${VITE_ENVIRONMENT_NAMES.server}\" environment not found`,\n    )\n  }\n\n  const clientEnv = builder.environments[VITE_ENVIRONMENT_NAMES.client]\n  if (!clientEnv) {\n    throw new Error(\n      `Vite's \"${VITE_ENVIRONMENT_NAMES.client}\" environment not found`,\n    )\n  }\n\n  const outputDir = clientEnv.config.build.outDir\n\n  const entryFile = findEntryFileInBundle(serverBundle)\n  let fullEntryFilePath = path.join(serverEnv.config.build.outDir, entryFile)\n  process.env.TSS_PRERENDERING = 'true'\n\n  if (!existsSync(fullEntryFilePath)) {\n    // if the file does not exist, we need to write the bundle to a temporary directory\n    // this can happen e.g. with nitro that postprocesses the bundle and thus does not write SSR build to disk\n    const bundleOutputDir = path.resolve(\n      serverEnv.config.root,\n      '.tanstack',\n      'start',\n      'prerender',\n    )\n    rmSync(bundleOutputDir, { recursive: true, force: true })\n    await writeBundleToDisk({ bundle: serverBundle, outDir: bundleOutputDir })\n    fullEntryFilePath = path.join(bundleOutputDir, entryFile)\n  }\n\n  const { default: serverEntrypoint } = await import(\n    pathToFileURL(fullEntryFilePath).toString()\n  )\n\n  function localFetch(path: string, options?: RequestInit): Promise<Response> {\n    const url = new URL(`http://localhost${path}`)\n    return serverEntrypoint.fetch(new Request(url, options))\n  }\n\n  try {\n    // Crawl all pages\n    const pages = await prerenderPages({ outputDir })\n\n    logger.info(`Prerendered ${pages.length} pages:`)\n    pages.forEach((page) => {\n      logger.info(`- ${page}`)\n    })\n  } catch (error) {\n    logger.error(error)\n  }\n\n  function extractLinks(html: string): Array<string> {\n    const linkRegex = /<a[^>]+href=[\"']([^\"']+)[\"'][^>]*>/g\n    const links: Array<string> = []\n    let match\n\n    while ((match = linkRegex.exec(html)) !== null) {\n      const href = match[1]\n      if (href && (href.startsWith('/') || href.startsWith('./'))) {\n        links.push(href)\n      }\n    }\n\n    return links\n  }\n\n  async function prerenderPages({ outputDir }: { outputDir: string }) {\n    const seen = new Set<string>()\n    const retriesByPath = new Map<string, number>()\n    const concurrency = startConfig.prerender?.concurrency ?? os.cpus().length\n    logger.info(`Concurrency: ${concurrency}`)\n    const queue = new Queue({ concurrency })\n\n    startConfig.pages.forEach((page) => addCrawlPageTask(page))\n\n    await queue.start()\n\n    return Array.from(seen)\n\n    function addCrawlPageTask(page: Page) {\n      // Was the page already seen?\n      if (seen.has(page.path)) return\n\n      // Add the page to the seen set\n      seen.add(page.path)\n\n      if (page.fromCrawl) {\n        startConfig.pages.push(page)\n      }\n\n      // If not enabled, skip\n      if (!(page.prerender?.enabled ?? true)) return\n\n      // If there is a filter link, check if the page should be prerendered\n      if (startConfig.prerender?.filter && !startConfig.prerender.filter(page))\n        return\n\n      // Resolve the merged default and page-specific prerender options\n      const prerenderOptions = {\n        ...startConfig.prerender,\n        ...page.prerender,\n      }\n\n      // Add the task\n      queue.add(async () => {\n        logger.info(`Crawling: ${page.path}`)\n        const retries = retriesByPath.get(page.path) || 0\n        try {\n          // Fetch the route\n          const encodedRoute = encodeURI(page.path)\n\n          const res = await localFetch(withBase(encodedRoute, TSS_APP_BASE), {\n            headers: {\n              ...prerenderOptions.headers,\n            },\n          })\n\n          if (!res.ok) {\n            throw new Error(`Failed to fetch ${page.path}: ${res.statusText}`, {\n              cause: res,\n            })\n          }\n\n          const cleanPagePath = (\n            prerenderOptions.outputPath || page.path\n          ).split(/[?#]/)[0]!\n\n          // Guess route type and populate fileName\n          const contentType = res.headers.get('content-type') || ''\n          const isImplicitHTML =\n            !cleanPagePath.endsWith('.html') && contentType.includes('html')\n          // &&\n          // !JsonSigRx.test(dataBuff.subarray(0, 32).toString('utf8'))\n          const routeWithIndex = cleanPagePath.endsWith('/')\n            ? cleanPagePath + 'index'\n            : cleanPagePath\n\n          const htmlPath =\n            cleanPagePath.endsWith('/') || prerenderOptions.autoSubfolderIndex\n              ? joinURL(cleanPagePath, 'index.html')\n              : cleanPagePath + '.html'\n\n          const filename = withoutBase(\n            isImplicitHTML ? htmlPath : routeWithIndex,\n            TSS_APP_BASE,\n          )\n\n          const html = await res.text()\n\n          const filepath = path.join(outputDir, filename)\n\n          await fsp.mkdir(path.dirname(filepath), {\n            recursive: true,\n          })\n\n          await fsp.writeFile(filepath, html)\n\n          const newPage = await prerenderOptions.onSuccess?.({ page, html })\n\n          if (newPage) {\n            Object.assign(page, newPage)\n          }\n\n          // Find new links\n          if (prerenderOptions.crawlLinks ?? true) {\n            const links = extractLinks(html)\n            for (const link of links) {\n              addCrawlPageTask({ path: link, fromCrawl: true })\n            }\n          }\n        } catch (error) {\n          if (retries < (prerenderOptions.retryCount ?? 0)) {\n            logger.warn(`Encountered error, retrying: ${page.path} in 500ms`)\n            await new Promise((resolve) =>\n              setTimeout(resolve, prerenderOptions.retryDelay),\n            )\n            retriesByPath.set(page.path, retries + 1)\n            addCrawlPageTask(page)\n          } else {\n            if (prerenderOptions.failOnError ?? true) {\n              throw error\n            }\n          }\n        }\n      })\n    }\n  }\n}\n\nfunction findEntryFileInBundle(bundle: Rollup.OutputBundle): string {\n  let entryFile: string | undefined\n\n  for (const [_name, file] of Object.entries(bundle)) {\n    if (file.type === 'chunk') {\n      if (file.isEntry) {\n        if (entryFile !== undefined) {\n          throw new Error(\n            `Multiple entry points found. Only one entry point is allowed.`,\n          )\n        }\n        entryFile = file.fileName\n      }\n    }\n  }\n  if (entryFile === undefined) {\n    throw new Error(`No entry point found in the bundle.`)\n  }\n  return entryFile\n}\n\nexport async function writeBundleToDisk({\n  bundle,\n  outDir,\n}: {\n  bundle: Rollup.OutputBundle\n  outDir: string\n}) {\n  for (const [fileName, asset] of Object.entries(bundle)) {\n    const fullPath = path.join(outDir, fileName)\n    const content = asset.type === 'asset' ? asset.source : asset.code\n    await fsp.mkdir(path.dirname(fullPath), { recursive: true })\n    await fsp.writeFile(fullPath, content)\n  }\n}\n"],"names":["path","outputDir","fsp"],"mappings":"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"}