{"version":3,"file":"compilers.js","sources":["../../../src/start-compiler-plugin/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport * as t from '@babel/types'\n\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport { handleCreateMiddleware } from '../create-server-fn-plugin/handleCreateMiddleware'\nimport { transformFuncs } from './constants'\nimport { handleCreateIsomorphicFnCallExpression } from './isomorphicFn'\nimport {\n  handleCreateClientOnlyFnCallExpression,\n  handleCreateServerOnlyFnCallExpression,\n} from './envOnly'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nexport type CompileStartFrameworkOptions = 'react' | 'solid'\n\ntype Identifiers = { [K in (typeof transformFuncs)[number]]: IdentifierConfig }\n\nexport function compileStartOutputFactory(\n  framework: CompileStartFrameworkOptions,\n) {\n  return function compileStartOutput(opts: CompileOptions): GeneratorResult {\n    const identifiers: Identifiers = {\n      createServerOnlyFn: {\n        name: 'createServerOnlyFn',\n        handleCallExpression: handleCreateServerOnlyFnCallExpression,\n        paths: [],\n      },\n      createClientOnlyFn: {\n        name: 'createClientOnlyFn',\n        handleCallExpression: handleCreateClientOnlyFnCallExpression,\n        paths: [],\n      },\n      createIsomorphicFn: {\n        name: 'createIsomorphicFn',\n        handleCallExpression: handleCreateIsomorphicFnCallExpression,\n        paths: [],\n      },\n      createMiddleware: {\n        name: 'createMiddleware',\n        handleCallExpression: handleCreateMiddleware,\n        paths: [],\n      },\n    }\n\n    const ast = parseAst(opts)\n\n    const doDce = opts.dce ?? true\n    // find referenced identifiers *before* we transform anything\n    const refIdents = doDce ? findReferencedIdentifiers(ast) : undefined\n\n    babel.traverse(ast, {\n      Program: {\n        enter(programPath) {\n          programPath.traverse({\n            ImportDeclaration: (path) => {\n              if (path.node.source.value !== `@tanstack/${framework}-start`) {\n                return\n              }\n\n              // handle a destructured imports being renamed like \"import { createServerFn as myCreateServerFn } from '@tanstack/react-start';\"\n              path.node.specifiers.forEach((specifier) => {\n                transformFuncs.forEach((identifierKey) => {\n                  const identifier = identifiers[identifierKey]\n\n                  if (\n                    specifier.type === 'ImportSpecifier' &&\n                    specifier.imported.type === 'Identifier'\n                  ) {\n                    if (specifier.imported.name === identifierKey) {\n                      identifier.name = specifier.local.name\n                    }\n                  }\n\n                  // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                  if (specifier.type === 'ImportNamespaceSpecifier') {\n                    identifier.name = `${specifier.local.name}.${identifierKey}`\n                  }\n                })\n              })\n            },\n            CallExpression: (path) => {\n              transformFuncs.forEach((identifierKey) => {\n                // Check to see if the call expression is a call to the\n                // identifiers[identifierKey].name\n                if (\n                  t.isIdentifier(path.node.callee) &&\n                  path.node.callee.name === identifiers[identifierKey].name\n                ) {\n                  // The identifier could be a call to the original function\n                  // in the source code. If this is case, we need to ignore it.\n                  // Check the scope to see if the identifier is a function declaration.\n                  // if it is, then we can ignore it.\n\n                  if (\n                    path.scope.getBinding(identifiers[identifierKey].name)?.path\n                      .node.type === 'FunctionDeclaration'\n                  ) {\n                    return\n                  }\n\n                  return identifiers[identifierKey].paths.push(path)\n                }\n\n                // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                // which are then called like \"TanStackStart.createServerFn()\"\n                if (t.isMemberExpression(path.node.callee)) {\n                  if (\n                    t.isIdentifier(path.node.callee.object) &&\n                    t.isIdentifier(path.node.callee.property)\n                  ) {\n                    const callname = [\n                      path.node.callee.object.name,\n                      path.node.callee.property.name,\n                    ].join('.')\n\n                    if (callname === identifiers[identifierKey].name) {\n                      identifiers[identifierKey].paths.push(path)\n                    }\n                  }\n                }\n\n                return\n              })\n            },\n          })\n\n          transformFuncs.forEach((identifierKey) => {\n            identifiers[identifierKey].paths.forEach((path) => {\n              identifiers[identifierKey].handleCallExpression(\n                path as babel.NodePath<t.CallExpression>,\n                opts,\n              )\n            })\n          })\n        },\n      },\n    })\n\n    if (doDce) {\n      deadCodeElimination(ast, refIdents)\n    }\n\n    return generateFromAst(ast, {\n      sourceMaps: true,\n      sourceFileName: opts.filename,\n      filename: opts.filename,\n    })\n  }\n}\n\nexport type CompileOptions = ParseAstOptions & {\n  env: 'server' | 'client'\n  dce?: boolean\n  filename: string\n}\n\nexport type IdentifierConfig = {\n  name: string\n  handleCallExpression: (\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) => void\n  paths: Array<babel.NodePath>\n}\n"],"names":[],"mappings":"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"}