{"version":3,"file":"isomorphicFn.js","sources":["../../../src/start-compiler-plugin/isomorphicFn.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport { getRootCallExpression } from './utils'\nimport type * as babel from '@babel/core'\n\nimport type { CompileOptions } from './compilers'\n\nexport function handleCreateIsomorphicFnCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: CompileOptions,\n) {\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createIsomorphicFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  const callExpressionPaths = {\n    client: null as babel.NodePath<t.CallExpression> | null,\n    server: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (\n    validMethods.every(\n      (method) =>\n        !callExpressionPaths[method as keyof typeof callExpressionPaths],\n    )\n  ) {\n    const variableId = rootCallExpression.parentPath.isVariableDeclarator()\n      ? rootCallExpression.parentPath.node.id\n      : null\n    console.warn(\n      'createIsomorphicFn called without a client or server implementation!',\n      'This will result in a no-op function.',\n      'Variable name:',\n      t.isIdentifier(variableId) ? variableId.name : 'unknown',\n    )\n  }\n\n  const envCallExpression = callExpressionPaths[opts.env]\n\n  if (!envCallExpression) {\n    // if we don't have an implementation for this environment, default to a no-op\n    rootCallExpression.replaceWith(\n      t.arrowFunctionExpression([], t.blockStatement([])),\n    )\n    return\n  }\n\n  const innerInputExpression = envCallExpression.node.arguments[0]\n\n  if (!t.isExpression(innerInputExpression)) {\n    throw new Error(\n      `createIsomorphicFn().${opts.env}(func) must be called with a function!`,\n    )\n  }\n\n  rootCallExpression.replaceWith(innerInputExpression)\n}\n"],"names":[],"mappings":";;AAMO,SAAS,uCACd,MACA,MACA;AACA,QAAM,qBAAqB,sBAAsB,IAAI;AAQrD,QAAM,sBAAsB;AAAA,IAC1B,QAAQ;AAAA,IACR,QAAQ;AAAA,EAAA;AAGV,QAAM,eAAe,OAAO,KAAK,mBAAmB;AAEpD,qBAAmB,SAAS;AAAA,IAC1B,iBAAiB,sBAAsB;AACrC,UAAI,EAAE,aAAa,qBAAqB,KAAK,QAAQ,GAAG;AACtD,cAAM,OAAO,qBAAqB,KAAK,SACpC;AAEH,YACE,aAAa,SAAS,IAAI,KAC1B,qBAAqB,WAAW,oBAChC;AACA,8BAAoB,IAAI,IAAI,qBAAqB;AAAA,QACnD;AAAA,MACF;AAAA,IACF;AAAA,EAAA,CACD;AAED,MACE,aAAa;AAAA,IACX,CAAC,WACC,CAAC,oBAAoB,MAA0C;AAAA,EAAA,GAEnE;AACA,UAAM,aAAa,mBAAmB,WAAW,qBAAA,IAC7C,mBAAmB,WAAW,KAAK,KACnC;AACJ,YAAQ;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,EAAE,aAAa,UAAU,IAAI,WAAW,OAAO;AAAA,IAAA;AAAA,EAEnD;AAEA,QAAM,oBAAoB,oBAAoB,KAAK,GAAG;AAEtD,MAAI,CAAC,mBAAmB;AAEtB,uBAAmB;AAAA,MACjB,EAAE,wBAAwB,CAAA,GAAI,EAAE,eAAe,CAAA,CAAE,CAAC;AAAA,IAAA;AAEpD;AAAA,EACF;AAEA,QAAM,uBAAuB,kBAAkB,KAAK,UAAU,CAAC;AAE/D,MAAI,CAAC,EAAE,aAAa,oBAAoB,GAAG;AACzC,UAAM,IAAI;AAAA,MACR,wBAAwB,KAAK,GAAG;AAAA,IAAA;AAAA,EAEpC;AAEA,qBAAmB,YAAY,oBAAoB;AACrD;"}