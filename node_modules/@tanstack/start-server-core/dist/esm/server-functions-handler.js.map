{"version":3,"file":"server-functions-handler.js","sources":["../../src/server-functions-handler.ts"],"sourcesContent":["import { isNotFound } from '@tanstack/router-core'\nimport invariant from 'tiny-invariant'\nimport {\n  TSS_FORMDATA_CONTEXT,\n  X_TSS_SERIALIZED,\n  getDefaultSerovalPlugins,\n} from '@tanstack/start-client-core'\nimport { fromJSON, toCrossJSONAsync, toCrossJSONStream } from 'seroval'\nimport { getResponse } from './request-response'\nimport { getServerFnById } from './getServerFnById'\n\nfunction sanitizeBase(base: string | undefined) {\n  if (!base) {\n    throw new Error(\n      'ðŸš¨ process.env.TSS_SERVER_FN_BASE is required in start/server-handler/index',\n    )\n  }\n\n  return base.replace(/^\\/|\\/$/g, '')\n}\n\nexport const handleServerAction = async ({\n  request,\n  context,\n}: {\n  request: Request\n  context: any\n}) => {\n  const controller = new AbortController()\n  const signal = controller.signal\n  const abort = () => controller.abort()\n  request.signal.addEventListener('abort', abort)\n\n  const method = request.method\n  const url = new URL(request.url, 'http://localhost:3000')\n  // extract the serverFnId from the url as host/_serverFn/:serverFnId\n  // Define a regex to match the path and extract the :thing part\n  const regex = new RegExp(\n    `${sanitizeBase(process.env.TSS_SERVER_FN_BASE)}/([^/?#]+)`,\n  )\n\n  // Execute the regex\n  const match = url.pathname.match(regex)\n  const serverFnId = match ? match[1] : null\n  const search = Object.fromEntries(url.searchParams.entries()) as {\n    payload?: any\n    createServerFn?: boolean\n  }\n\n  const isCreateServerFn = 'createServerFn' in search\n\n  if (typeof serverFnId !== 'string') {\n    throw new Error('Invalid server action param for serverFnId: ' + serverFnId)\n  }\n\n  const action = await getServerFnById(serverFnId)\n\n  // Known FormData 'Content-Type' header values\n  const formDataContentTypes = [\n    'multipart/form-data',\n    'application/x-www-form-urlencoded',\n  ]\n\n  const contentType = request.headers.get('Content-Type')\n  const serovalPlugins = getDefaultSerovalPlugins()\n\n  function parsePayload(payload: any) {\n    const parsedPayload = fromJSON(payload, { plugins: serovalPlugins })\n    return parsedPayload as any\n  }\n\n  const response = await (async () => {\n    try {\n      let result = await (async () => {\n        // FormData\n        if (\n          formDataContentTypes.some(\n            (type) => contentType && contentType.includes(type),\n          )\n        ) {\n          // We don't support GET requests with FormData payloads... that seems impossible\n          invariant(\n            method.toLowerCase() !== 'get',\n            'GET requests with FormData payloads are not supported',\n          )\n          const formData = await request.formData()\n          const serializedContext = formData.get(TSS_FORMDATA_CONTEXT)\n          formData.delete(TSS_FORMDATA_CONTEXT)\n\n          const params = {\n            context,\n            data: formData,\n          }\n          if (typeof serializedContext === 'string') {\n            try {\n              const parsedContext = JSON.parse(serializedContext)\n              if (typeof parsedContext === 'object' && parsedContext) {\n                params.context = { ...context, ...parsedContext }\n              }\n            } catch {}\n          }\n\n          return await action(params, signal)\n        }\n\n        // Get requests use the query string\n        if (method.toLowerCase() === 'get') {\n          invariant(\n            isCreateServerFn,\n            'expected GET request to originate from createServerFn',\n          )\n          // By default the payload is the search params\n          let payload: any = search.payload\n          // If there's a payload, we should try to parse it\n          payload = payload ? parsePayload(JSON.parse(payload)) : payload\n          payload.context = { ...context, ...payload.context }\n          // Send it through!\n          return await action(payload, signal)\n        }\n\n        if (method.toLowerCase() !== 'post') {\n          throw new Error('expected POST method')\n        }\n\n        if (!contentType || !contentType.includes('application/json')) {\n          throw new Error('expected application/json content type')\n        }\n\n        const jsonPayload = await request.json()\n\n        // If this POST request was created by createServerFn,\n        // its payload  will be the only argument\n        if (isCreateServerFn) {\n          const payload = parsePayload(jsonPayload)\n          payload.context = { ...payload.context, ...context }\n          return await action(payload, signal)\n        }\n\n        // Otherwise, we'll spread the payload. Need to\n        // support `use server` functions that take multiple\n        // arguments.\n        return await action(...jsonPayload)\n      })()\n\n      // Any time we get a Response back, we should just\n      // return it immediately.\n      if (result.result instanceof Response) {\n        return result.result\n      }\n\n      // If this is a non createServerFn request, we need to\n      // pull out the result from the result object\n      if (!isCreateServerFn) {\n        result = result.result\n\n        // The result might again be a response,\n        // and if it is, return it.\n        if (result instanceof Response) {\n          return result\n        }\n      }\n\n      // TODO: RSCs Where are we getting this package?\n      // if (isValidElement(result)) {\n      //   const { renderToPipeableStream } = await import(\n      //     // @ts-expect-error\n      //     'react-server-dom/server'\n      //   )\n\n      //   const pipeableStream = renderToPipeableStream(result)\n\n      //   setHeaders(event, {\n      //     'Content-Type': 'text/x-component',\n      //   } as any)\n\n      //   sendStream(event, response)\n      //   event._handled = true\n\n      //   return new Response(null, { status: 200 })\n      // }\n\n      if (isNotFound(result)) {\n        return isNotFoundResponse(result)\n      }\n\n      const response = getResponse()\n      let nonStreamingBody: any = undefined\n\n      if (result !== undefined) {\n        // first run without the stream in case `result` does not need streaming\n        let done = false as boolean\n        const callbacks: {\n          onParse: (value: any) => void\n          onDone: () => void\n          onError: (error: any) => void\n        } = {\n          onParse: (value) => {\n            nonStreamingBody = value\n          },\n          onDone: () => {\n            done = true\n          },\n          onError: (error) => {\n            throw error\n          },\n        }\n        toCrossJSONStream(result, {\n          refs: new Map(),\n          plugins: serovalPlugins,\n          onParse(value) {\n            callbacks.onParse(value)\n          },\n          onDone() {\n            callbacks.onDone()\n          },\n          onError: (error) => {\n            callbacks.onError(error)\n          },\n        })\n        if (done) {\n          return new Response(\n            nonStreamingBody ? JSON.stringify(nonStreamingBody) : undefined,\n            {\n              status: response?.status,\n              statusText: response?.statusText,\n              headers: {\n                'Content-Type': 'application/json',\n                [X_TSS_SERIALIZED]: 'true',\n              },\n            },\n          )\n        }\n\n        // not done yet, we need to stream\n        const stream = new ReadableStream({\n          start(controller) {\n            callbacks.onParse = (value) =>\n              controller.enqueue(JSON.stringify(value) + '\\n')\n            callbacks.onDone = () => {\n              try {\n                controller.close()\n              } catch (error) {\n                controller.error(error)\n              }\n            }\n            callbacks.onError = (error) => controller.error(error)\n            // stream the initial body\n            if (nonStreamingBody !== undefined) {\n              callbacks.onParse(nonStreamingBody)\n            }\n          },\n        })\n        return new Response(stream, {\n          status: response?.status,\n          statusText: response?.statusText,\n          headers: {\n            'Content-Type': 'application/x-ndjson',\n            [X_TSS_SERIALIZED]: 'true',\n          },\n        })\n      }\n\n      return new Response(undefined, {\n        status: response?.status,\n        statusText: response?.statusText,\n      })\n    } catch (error: any) {\n      if (error instanceof Response) {\n        return error\n      }\n      // else if (\n      //   isPlainObject(error) &&\n      //   'result' in error &&\n      //   error.result instanceof Response\n      // ) {\n      //   return error.result\n      // }\n\n      // Currently this server-side context has no idea how to\n      // build final URLs, so we need to defer that to the client.\n      // The client will check for __redirect and __notFound keys,\n      // and if they exist, it will handle them appropriately.\n\n      if (isNotFound(error)) {\n        return isNotFoundResponse(error)\n      }\n\n      console.info()\n      console.info('Server Fn Error!')\n      console.info()\n      console.error(error)\n      console.info()\n\n      const serializedError = JSON.stringify(\n        await Promise.resolve(\n          toCrossJSONAsync(error, {\n            refs: new Map(),\n            plugins: serovalPlugins,\n          }),\n        ),\n      )\n      const response = getResponse()\n      return new Response(serializedError, {\n        status: response?.status ?? 500,\n        statusText: response?.statusText,\n        headers: {\n          'Content-Type': 'application/json',\n          [X_TSS_SERIALIZED]: 'true',\n        },\n      })\n    }\n  })()\n\n  request.signal.removeEventListener('abort', abort)\n\n  return response\n}\n\nfunction isNotFoundResponse(error: any) {\n  const { headers, ...rest } = error\n\n  return new Response(JSON.stringify(rest), {\n    status: 404,\n    headers: {\n      'Content-Type': 'application/json',\n      ...(headers || {}),\n    },\n  })\n}\n"],"names":["response","controller"],"mappings":"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"}