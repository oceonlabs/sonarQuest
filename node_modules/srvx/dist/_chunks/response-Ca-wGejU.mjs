import { splitSetCookieString } from "cookie-es";

//#region src/adapters/_node/_common.ts
const kNodeInspect = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");

//#endregion
//#region src/adapters/_node/headers.ts
const NodeRequestHeaders = /* @__PURE__ */ (() => {
	const _Headers = class Headers$1 {
		_node;
		constructor(nodeCtx) {
			this._node = nodeCtx;
		}
		append(name, value) {
			name = validateHeader(name);
			const _headers = this._node.req.headers;
			const _current = _headers[name];
			if (_current) if (Array.isArray(_current)) _current.push(value);
			else _headers[name] = [_current, value];
			else _headers[name] = value;
		}
		delete(name) {
			name = validateHeader(name);
			this._node.req.headers[name] = void 0;
		}
		get(name) {
			name = validateHeader(name);
			const rawValue = this._node.req.headers[name];
			if (rawValue === void 0) return null;
			return _normalizeValue(this._node.req.headers[name]);
		}
		getSetCookie() {
			const setCookie = this._node.req.headers["set-cookie"];
			if (!setCookie || setCookie.length === 0) return [];
			return splitSetCookieString(setCookie);
		}
		has(name) {
			name = validateHeader(name);
			return !!this._node.req.headers[name];
		}
		set(name, value) {
			name = validateHeader(name);
			this._node.req.headers[name] = value;
		}
		get count() {
			throw new Error("Method not implemented.");
		}
		getAll(_name) {
			throw new Error("Method not implemented.");
		}
		toJSON() {
			const _headers = this._node.req.headers;
			const result = {};
			for (const key in _headers) if (_headers[key]) result[key] = _normalizeValue(_headers[key]);
			return result;
		}
		forEach(cb, thisArg) {
			const _headers = this._node.req.headers;
			for (const key in _headers) if (_headers[key]) cb.call(thisArg, _normalizeValue(_headers[key]), key, this);
		}
		*entries() {
			const headers = this._node.req.headers;
			const isHttp2 = this._node.req.httpVersion === "2.0";
			for (const key in headers) if (!isHttp2 || key[0] !== ":") yield [key, _normalizeValue(headers[key])];
		}
		*keys() {
			const keys = Object.keys(this._node.req.headers);
			for (const key of keys) yield key;
		}
		*values() {
			const values = Object.values(this._node.req.headers);
			for (const value of values) yield _normalizeValue(value);
		}
		[Symbol.iterator]() {
			return this.entries()[Symbol.iterator]();
		}
		get [Symbol.toStringTag]() {
			return "Headers";
		}
		[kNodeInspect]() {
			return Object.fromEntries(this.entries());
		}
	};
	Object.setPrototypeOf(_Headers.prototype, globalThis.Headers.prototype);
	return _Headers;
})();
const NodeResponseHeaders = /* @__PURE__ */ (() => {
	const _Headers = class Headers$1 {
		_node;
		constructor(nodeCtx) {
			this._node = nodeCtx;
		}
		append(name, value) {
			this._node.res.appendHeader(name, value);
		}
		delete(name) {
			this._node.res.removeHeader(name);
		}
		get(name) {
			const rawValue = this._node.res.getHeader(name);
			if (rawValue === void 0) return null;
			return _normalizeValue(rawValue);
		}
		getSetCookie() {
			const setCookie = _normalizeValue(this._node.res.getHeader("set-cookie"));
			if (!setCookie) return [];
			return splitSetCookieString(setCookie);
		}
		has(name) {
			return this._node.res.hasHeader(name);
		}
		set(name, value) {
			this._node.res.setHeader(name, value);
		}
		get count() {
			throw new Error("Method not implemented.");
		}
		getAll(_name) {
			throw new Error("Method not implemented.");
		}
		toJSON() {
			const _headers = this._node.res.getHeaders();
			const result = {};
			for (const key in _headers) if (_headers[key]) result[key] = _normalizeValue(_headers[key]);
			return result;
		}
		forEach(cb, thisArg) {
			const _headers = this._node.res.getHeaders();
			for (const key in _headers) if (_headers[key]) cb.call(thisArg, _normalizeValue(_headers[key]), key, this);
		}
		*entries() {
			const _headers = this._node.res.getHeaders();
			for (const key in _headers) yield [key, _normalizeValue(_headers[key])];
		}
		*keys() {
			const keys = this._node.res.getHeaderNames();
			for (const key of keys) yield key;
		}
		*values() {
			const values = Object.values(this._node.res.getHeaders());
			for (const value of values) yield _normalizeValue(value);
		}
		[Symbol.iterator]() {
			return this.entries()[Symbol.iterator]();
		}
		get [Symbol.toStringTag]() {
			return "Headers";
		}
		[kNodeInspect]() {
			return Object.fromEntries(this.entries());
		}
	};
	Object.setPrototypeOf(_Headers.prototype, globalThis.Headers.prototype);
	return _Headers;
})();
function _normalizeValue(value) {
	if (Array.isArray(value)) return value.join(", ");
	return typeof value === "string" ? value : String(value ?? "");
}
function validateHeader(name) {
	if (name[0] === ":") throw new TypeError(`${JSON.stringify(name)} is an invalid header name.`);
	return name.toLowerCase();
}

//#endregion
//#region src/adapters/_node/response.ts
/**
* Fast Response for Node.js runtime
*
* It is faster because in most cases it doesn't create a full Response instance.
*/
const NodeResponse = /* @__PURE__ */ (() => {
	const CONTENT_TYPE = "content-type";
	const JSON_TYPE = "application/json";
	const JSON_HEADER = [[CONTENT_TYPE, JSON_TYPE]];
	const _Response = class Response {
		#body;
		#init;
		constructor(body, init) {
			this.#body = body;
			this.#init = init;
		}
		static json(data, init) {
			if (init?.headers) {
				if (!init.headers[CONTENT_TYPE]) {
					const initHeaders = new Headers(init.headers);
					if (!initHeaders.has(CONTENT_TYPE)) initHeaders.set(CONTENT_TYPE, JSON_TYPE);
					init = {
						...init,
						headers: initHeaders
					};
				}
			} else {
				init = init ? { ...init } : {};
				init.headers = JSON_HEADER;
			}
			return new _Response(JSON.stringify(data), init);
		}
		static error() {
			return globalThis.Response.error();
		}
		static redirect(url, status) {
			return globalThis.Response.redirect(url, status);
		}
		/**
		* Prepare Node.js response object
		*/
		nodeResponse() {
			const status = this.#init?.status ?? 200;
			const statusText = this.#init?.statusText ?? "";
			const headers = [];
			const headersInit = this.#init?.headers;
			if (this.#headersObj) for (const [key, value] of this.#headersObj) if (key === "set-cookie") for (const setCookie of splitSetCookieString(value)) headers.push(["set-cookie", setCookie]);
			else headers.push([key, value]);
			else if (headersInit) {
				const headerEntries = Array.isArray(headersInit) ? headersInit : headersInit.entries ? headersInit.entries() : Object.entries(headersInit);
				for (const [key, value] of headerEntries) if (key === "set-cookie") for (const setCookie of splitSetCookieString(value)) headers.push(["set-cookie", setCookie]);
				else headers.push([key, value]);
			}
			const bodyInit = this.#body;
			let body;
			if (bodyInit) if (typeof bodyInit === "string") body = bodyInit;
			else if (bodyInit instanceof ReadableStream) body = bodyInit;
			else if (bodyInit instanceof ArrayBuffer) body = Buffer.from(bodyInit);
			else if (bodyInit instanceof Uint8Array) body = Buffer.from(bodyInit);
			else if (bodyInit instanceof DataView) body = Buffer.from(bodyInit.buffer);
			else if (bodyInit instanceof Blob) {
				body = bodyInit.stream();
				if (bodyInit.type) headers.push(["content-type", bodyInit.type]);
			} else if (typeof bodyInit.pipe === "function") body = bodyInit;
			else {
				const res = new globalThis.Response(bodyInit);
				body = res.body;
				for (const [key, value] of res.headers) headers.push([key, value]);
			}
			this.#body = void 0;
			this.#init = void 0;
			this.#headersObj = void 0;
			this.#responseObj = void 0;
			return {
				status,
				statusText,
				headers,
				body
			};
		}
		/** Lazy initialized response instance */
		#responseObj;
		/** Lazy initialized headers instance */
		#headersObj;
		clone() {
			if (this.#responseObj) return this.#responseObj.clone();
			if (this.#headersObj) return new _Response(this.#body, {
				...this.#init,
				headers: this.#headersObj
			});
			return new _Response(this.#body, this.#init);
		}
		get #response() {
			if (!this.#responseObj) {
				this.#responseObj = this.#headersObj ? new globalThis.Response(this.#body, {
					...this.#init,
					headers: this.#headersObj
				}) : new globalThis.Response(this.#body, this.#init);
				this.#body = void 0;
				this.#init = void 0;
				this.#headersObj = void 0;
			}
			return this.#responseObj;
		}
		get headers() {
			if (this.#responseObj) return this.#responseObj.headers;
			if (!this.#headersObj) this.#headersObj = new Headers(this.#init?.headers);
			return this.#headersObj;
		}
		get ok() {
			if (this.#responseObj) return this.#responseObj.ok;
			const status = this.#init?.status ?? 200;
			return status >= 200 && status < 300;
		}
		get redirected() {
			if (this.#responseObj) return this.#responseObj.redirected;
			return false;
		}
		get status() {
			if (this.#responseObj) return this.#responseObj.status;
			return this.#init?.status ?? 200;
		}
		get statusText() {
			if (this.#responseObj) return this.#responseObj.statusText;
			return this.#init?.statusText ?? "";
		}
		get type() {
			if (this.#responseObj) return this.#responseObj.type;
			return "default";
		}
		get url() {
			if (this.#responseObj) return this.#responseObj.url;
			return "";
		}
		#fastBody(as) {
			const bodyInit = this.#body;
			if (bodyInit === null || bodyInit === void 0) return null;
			if (bodyInit instanceof as) return bodyInit;
			return false;
		}
		get body() {
			if (this.#responseObj) return this.#responseObj.body;
			const fastBody = this.#fastBody(ReadableStream);
			if (fastBody !== false) return fastBody;
			return this.#response.body;
		}
		get bodyUsed() {
			if (this.#responseObj) return this.#responseObj.bodyUsed;
			return false;
		}
		arrayBuffer() {
			if (this.#responseObj) return this.#responseObj.arrayBuffer();
			const fastBody = this.#fastBody(ArrayBuffer);
			if (fastBody !== false) return Promise.resolve(fastBody || new ArrayBuffer(0));
			return this.#response.arrayBuffer();
		}
		blob() {
			if (this.#responseObj) return this.#responseObj.blob();
			const fastBody = this.#fastBody(Blob);
			if (fastBody !== false) return Promise.resolve(fastBody || new Blob());
			return this.#response.blob();
		}
		bytes() {
			if (this.#responseObj) return this.#responseObj.bytes();
			const fastBody = this.#fastBody(Uint8Array);
			if (fastBody !== false) return Promise.resolve(fastBody || new Uint8Array());
			return this.#response.bytes();
		}
		formData() {
			if (this.#responseObj) return this.#responseObj.formData();
			const fastBody = this.#fastBody(FormData);
			if (fastBody !== false) return Promise.resolve(fastBody || new FormData());
			return this.#response.formData();
		}
		text() {
			if (this.#responseObj) return this.#responseObj.text();
			const bodyInit = this.#body;
			if (bodyInit === null || bodyInit === void 0) return Promise.resolve("");
			if (typeof bodyInit === "string") return Promise.resolve(bodyInit);
			return this.#response.text();
		}
		json() {
			if (this.#responseObj) return this.#responseObj.json();
			return this.text().then((text) => JSON.parse(text));
		}
	};
	Object.setPrototypeOf(_Response.prototype, globalThis.Response.prototype);
	return _Response;
})();

//#endregion
export { NodeRequestHeaders, NodeResponse, NodeResponseHeaders, kNodeInspect };